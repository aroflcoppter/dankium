From 2eb0b9c1a7b473e897d475c02a2112fcae232b3d Mon Sep 17 00:00:00 2001
From: aroflcoppter <contact@dankium.ca>
Date: Wed, 4 Jun 2025 01:20:31 -0230
Subject: [PATCH] Dankium Config

---
 base/command_line.cc | 903 ++++++++++++++++++++++++-------------------
 1 file changed, 499 insertions(+), 404 deletions(-)

diff --git a/base/command_line.cc b/base/command_line.cc
index d4d3bc52426d1..9f40acddae57b 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -66,7 +66,7 @@ constexpr auto kSwitchPrefixes = std::to_array<CommandLine::StringViewType>({
 size_t switch_prefix_count = std::size(kSwitchPrefixes);
 
 bool IsSwitchNameValid(std::string_view switch_name) {
-  return ToLowerASCII(switch_name) == switch_name;
+    return ToLowerASCII(switch_name) == switch_name;
 }
 
 #if BUILDFLAG(IS_WIN)
@@ -81,13 +81,13 @@ constexpr CommandLine::CharType kSingleArgument[] =
 #endif  // BUILDFLAG(IS_WIN)
 
 size_t GetSwitchPrefixLength(CommandLine::StringViewType string) {
-  for (size_t i = 0; i < switch_prefix_count; ++i) {
-    CommandLine::StringType prefix(kSwitchPrefixes[i]);
-    if (string.substr(0, prefix.length()) == prefix) {
-      return prefix.length();
+    for (size_t i = 0; i < switch_prefix_count; ++i) {
+        CommandLine::StringType prefix(kSwitchPrefixes[i]);
+        if (string.substr(0, prefix.length()) == prefix) {
+            return prefix.length();
+        }
     }
-  }
-  return 0;
+    return 0;
 }
 
 // Fills in |switch_string| and |switch_value| if |string| is a switch.
@@ -95,33 +95,33 @@ size_t GetSwitchPrefixLength(CommandLine::StringViewType string) {
 bool IsSwitch(const CommandLine::StringType& string,
               CommandLine::StringType* switch_string,
               CommandLine::StringType* switch_value) {
-  switch_string->clear();
-  switch_value->clear();
-  size_t prefix_length = GetSwitchPrefixLength(string);
-  if (prefix_length == 0 || prefix_length == string.length()) {
-    return false;
-  }
+    switch_string->clear();
+    switch_value->clear();
+    size_t prefix_length = GetSwitchPrefixLength(string);
+    if (prefix_length == 0 || prefix_length == string.length()) {
+        return false;
+    }
 
-  const size_t equals_position = string.find(kSwitchValueSeparator);
-  *switch_string = string.substr(0, equals_position);
-  if (equals_position != CommandLine::StringType::npos) {
-    *switch_value = string.substr(equals_position + 1);
-  }
-  return true;
+    const size_t equals_position = string.find(kSwitchValueSeparator);
+    *switch_string = string.substr(0, equals_position);
+    if (equals_position != CommandLine::StringType::npos) {
+        *switch_value = string.substr(equals_position + 1);
+    }
+    return true;
 }
 
 // Returns true iff |string| represents a switch with key
 // |switch_key_without_prefix|, regardless of value.
 bool IsSwitchWithKey(CommandLine::StringViewType string,
                      CommandLine::StringViewType switch_key_without_prefix) {
-  size_t prefix_length = GetSwitchPrefixLength(string);
-  if (prefix_length == 0 || prefix_length == string.length()) {
-    return false;
-  }
+    size_t prefix_length = GetSwitchPrefixLength(string);
+    if (prefix_length == 0 || prefix_length == string.length()) {
+        return false;
+    }
 
-  const size_t equals_position = string.find(kSwitchValueSeparator);
-  return string.substr(prefix_length, equals_position - prefix_length) ==
-         switch_key_without_prefix;
+    const size_t equals_position = string.find(kSwitchValueSeparator);
+    return string.substr(prefix_length, equals_position - prefix_length) ==
+           switch_key_without_prefix;
 }
 
 #if BUILDFLAG(IS_WIN)
@@ -131,74 +131,107 @@ bool IsSwitchWithKey(CommandLine::StringViewType string,
 std::wstring QuoteForCommandLineToArgvWInternal(
     const std::wstring& arg,
     bool allow_unsafe_insert_sequences) {
-  // Ensures that GetCommandLineString isn't used to generate command-line
-  // strings for the Windows shell by checking for Windows insert sequences like
-  // "%1". GetCommandLineStringForShell should be used instead to get a string
-  // with the correct placeholder format for the shell.
-  DCHECK(arg.size() != 2 || arg[0] != L'%' || allow_unsafe_insert_sequences);
-
-  constexpr wchar_t kQuotableCharacters[] = L" \t\\\"";
-  if (arg.find_first_of(kQuotableCharacters) == std::wstring::npos) {
-    return arg;
-  }
-
-  std::wstring out(1, L'"');
-  for (size_t i = 0; i < arg.size(); ++i) {
-    if (arg[i] == L'\\') {
-      // Finds the extent of this run of backslashes.
-      size_t end = i + 1;
-      while (end < arg.size() && arg[end] == L'\\') {
-        ++end;
-      }
-
-      const size_t backslash_count = end - i;
-
-      // Backslashes are escaped only if the run is followed by a double quote.
-      // Since we also will end the string with a double quote, we escape for
-      // either a double quote or the end of the string.
-      const size_t backslash_multiplier =
-          (end == arg.size() || arg[end] == L'"') ? 2 : 1;
-
-      out.append(std::wstring(backslash_count * backslash_multiplier, L'\\'));
+    // Ensures that GetCommandLineString isn't used to generate command-line
+    // strings for the Windows shell by checking for Windows insert sequences like
+    // "%1". GetCommandLineStringForShell should be used instead to get a string
+    // with the correct placeholder format for the shell.
+    DCHECK(arg.size() != 2 || arg[0] != L'%' || allow_unsafe_insert_sequences);
+
+    constexpr wchar_t kQuotableCharacters[] = L" \t\\\"";
+    if (arg.find_first_of(kQuotableCharacters) == std::wstring::npos) {
+        return arg;
+    }
 
-      // Advances `i` to one before `end` to balance `++i` in loop.
-      i = end - 1;
-    } else if (arg[i] == L'"') {
-      out.append(LR"(\")");
-    } else {
-      out.push_back(arg[i]);
+    std::wstring out(1, L'"');
+    for (size_t i = 0; i < arg.size(); ++i) {
+        if (arg[i] == L'\\') {
+            // Finds the extent of this run of backslashes.
+            size_t end = i + 1;
+            while (end < arg.size() && arg[end] == L'\\') {
+                ++end;
+            }
+
+            const size_t backslash_count = end - i;
+
+            // Backslashes are escaped only if the run is followed by a double quote.
+            // Since we also will end the string with a double quote, we escape for
+            // either a double quote or the end of the string.
+            const size_t backslash_multiplier =
+                (end == arg.size() || arg[end] == L'"') ? 2 : 1;
+
+            out.append(std::wstring(backslash_count * backslash_multiplier, L'\\'));
+
+            // Advances `i` to one before `end` to balance `++i` in loop.
+            i = end - 1;
+        } else if (arg[i] == L'"') {
+            out.append(LR"(\")");
+        } else {
+            out.push_back(arg[i]);
+        }
     }
-  }
 
-  out.push_back(L'"');
+    out.push_back(L'"');
 
-  return out;
+    return out;
 }
 #endif  // BUILDFLAG(IS_WIN)
 
 }  // namespace
 
+// Custom command-line arguments for POSIX/Fuchsia platforms
+const char* dankium_argv[] = {
+    "chromium",
+    "--no-first-run",
+    "--disable-features=ThirdPartyCookies,FieldTrials,Variations,NetworkPrediction,MetricsReporting,CrashReporting,ArticleSuggestions,ContentFeed,Sensors,ProtectedMediaPlaying,BackgroundSync,MediaRouterRemoting,MediaRouter,DrmPreprovisioning,AutofillCommunication,ComponentUpdatePings,Omaha,GaiaAuthCode,PrivacySandbox,PrivacyAwareAnalyticsTrials,OptimizationGuides,OptimizationGuidesFetching",
+    "--disable-background-networking",
+    "--no-pings",
+    "--disable-breakpad",
+    "--disable-metrics",
+    "--disable-auto-update",
+    "--disable-sync-config-for-tests",
+    "--disable-network-time",
+    "--enable-features=HttpsOnlyMode,PrefetchPrivacyChanges,SplitCacheByNetworkIsolationKey,PartitionConnectionsByNetworkIsolationKey,DoNotTrack,StrictSiteIsolation,StrictOriginIsolation,ReduceAcceptLanguage,ContentSettingsPartitioning,CertificateTransparency,WebRtcAllowProxiedOnly"
+};
+int dankium_argc = std::size(dankium_argv);
+
+// Custom command-line arguments for Android platform
+const char* dankium_android_argv[] = {
+    "chromium",
+    "--no-first-run",
+    "--disable-features=ThirdPartyCookies,FieldTrials,Variations,NetworkPrediction,MetricsReporting,CrashReporting,ArticleSuggestions,ContentFeed,Sensors,ProtectedMediaPlaying,BackgroundSync,MediaRouterRemoting,MediaRouter,DrmPreprovisioning,AutofillCommunication,ComponentUpdatePings,Omaha,GaiaAuthCode,PrivacySandbox,PrivacyAwareAnalyticsTrials,OptimizationGuides,OptimizationGuidesFetching",
+    "--disable-background-networking",
+    "--no-pings",
+    "--disable-sync",
+    "--disable-breakpad",
+    "--disable-metrics",
+    "--disable-auto-update",
+    "--disable-sync-config-for-tests",
+    "--disable-network-time",
+    "--enable-features=HttpsOnlyMode,PrefetchPrivacyChanges,SplitCacheByNetworkIsolationKey,PartitionConnectionsByNetworkIsolationKey,DoNotTrack,StrictSiteIsolation,StrictOriginIsolation,ReduceAcceptLanguage,ContentSettingsPartitioning,CertificateTransparency,WebRtcAllowProxiedOnly"
+};
+int dankium_android_argc = std::size(dankium_android_argv);
+
 // static
 void CommandLine::SetDuplicateSwitchHandler(
     std::unique_ptr<DuplicateSwitchHandler> new_duplicate_switch_handler) {
-  delete g_duplicate_switch_handler;
-  g_duplicate_switch_handler = new_duplicate_switch_handler.release();
+    delete g_duplicate_switch_handler;
+    g_duplicate_switch_handler = new_duplicate_switch_handler.release();
 }
 
 CommandLine::CommandLine(NoProgram no_program) : argv_(1), begin_args_(1) {}
 
 CommandLine::CommandLine(const FilePath& program) : argv_(1), begin_args_(1) {
-  SetProgram(program);
+    SetProgram(program);
 }
 
 CommandLine::CommandLine(int argc, const CommandLine::CharType* const* argv)
     : argv_(1), begin_args_(1) {
-  // SAFETY: required from caller.
-  UNSAFE_BUFFERS(InitFromArgv(argc, argv));
+    // SAFETY: required from caller.
+    UNSAFE_BUFFERS(InitFromArgv(argc, argv));
 }
 
 CommandLine::CommandLine(const StringVector& argv) : argv_(1), begin_args_(1) {
-  InitFromArgv(argv);
+    InitFromArgv(argv);
 }
 
 CommandLine::CommandLine(const CommandLine& other) = default;
@@ -214,256 +247,318 @@ CommandLine::CommandLine(CommandLine&& other) noexcept
       switches_(std::move(other.switches_)),
       begin_args_(std::exchange(other.begin_args_, 1)) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  other.sequence_checker_.Detach();
+    other.sequence_checker_.Detach();
 #endif
 }
 CommandLine& CommandLine::operator=(const CommandLine& other) = default;
 CommandLine& CommandLine::operator=(CommandLine&& other) noexcept {
 #if BUILDFLAG(IS_WIN)
-  raw_command_line_string_ =
-      std::exchange(other.raw_command_line_string_, StringViewType());
-  has_single_argument_switch_ =
-      std::exchange(other.has_single_argument_switch_, false);
+    raw_command_line_string_ =
+        std::exchange(other.raw_command_line_string_, StringViewType());
+    has_single_argument_switch_ =
+        std::exchange(other.has_single_argument_switch_, false);
 #endif  // BUILDFLAG(IS_WIN)
-  argv_ = std::exchange(other.argv_, StringVector(1));
-  switches_ = std::move(other.switches_);
-  begin_args_ = std::exchange(other.begin_args_, 1);
+    argv_ = std::exchange(other.argv_, StringVector(1));
+    switches_ = std::move(other.switches_);
+    begin_args_ = std::exchange(other.begin_args_, 1);
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  other.sequence_checker_.Detach();
+    other.sequence_checker_.Detach();
 #endif
-  return *this;
+    return *this;
 }
 CommandLine::~CommandLine() = default;
 
 #if BUILDFLAG(IS_WIN)
 // static
 void CommandLine::set_slash_is_not_a_switch() {
-  // The last switch prefix should be slash, so adjust the size to skip it.
-  static_assert(base::span(kSwitchPrefixes).back() == L"/",
-                "Error: Last switch prefix is not a slash.");
-  switch_prefix_count = std::size(kSwitchPrefixes) - 1;
+    // The last switch prefix should be slash, so adjust the size to skip it.
+    static_assert(base::span(kSwitchPrefixes).back() == L"/",
+                  "Error: Last switch prefix is not a slash.");
+    switch_prefix_count = std::size(kSwitchPrefixes) - 1;
 }
 
 // static
 void CommandLine::InitUsingArgvForTesting(int argc, const char* const* argv) {
-  DCHECK(!current_process_commandline_);
-  current_process_commandline_ = new CommandLine(NO_PROGRAM);
-  // On Windows we need to convert the command line arguments to std::wstring.
-  CommandLine::StringVector argv_vector;
-  for (int i = 0; i < argc; ++i) {
-    // SAFETY: required from caller.
-    argv_vector.push_back(UTF8ToWide(UNSAFE_BUFFERS(argv[i])));
-  }
-  current_process_commandline_->InitFromArgv(argv_vector);
+    DCHECK(!current_process_commandline_);
+    current_process_commandline_ = new CommandLine(NO_PROGRAM);
+    // On Windows we need to convert the command line arguments to std::wstring.
+    CommandLine::StringVector argv_vector;
+    for (int i = 0; i < argc; ++i) {
+        // SAFETY: required from caller.
+        argv_vector.push_back(UTF8ToWide(UNSAFE_BUFFERS(argv[i])));
+    }
+    current_process_commandline_->InitFromArgv(argv_vector);
 }
 #endif  // BUILDFLAG(IS_WIN)
 
 // static
 bool CommandLine::Init(int argc, const char* const* argv) {
-  if (current_process_commandline_) {
-    // If this is intentional, Reset() must be called first. If we are using
-    // the shared build mode, we have to share a single object across multiple
-    // shared libraries.
-    return false;
-  }
-
-  current_process_commandline_ = new CommandLine(NO_PROGRAM);
+    if (current_process_commandline_) {
+        // If this is intentional, Reset() must be called first. If we are using
+        // the shared build mode, we have to share a single object across multiple
+        // shared libraries.
+        return false;
+    }
+
+    current_process_commandline_ = new CommandLine(NO_PROGRAM);
+
+    FilePath program_path;
+    bool is_renderer_process = false;
 #if BUILDFLAG(IS_WIN)
-  current_process_commandline_->ParseFromString(::GetCommandLineW());
+    const std::wstring raw_command_line_w = ::GetCommandLineW();
+    program_path = FilePath(raw_command_line_w).BaseName();
+    // Check for renderer process type in the raw command line string.
+    // A simple substring search is sufficient for this specific flag.
+    if (raw_command_line_w.find(L"--type=renderer") != std::wstring::npos ||
+        raw_command_line_w.find(L"--process-type=renderer") != std::wstring::npos) {
+        is_renderer_process = true;
+    }
+#elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA) || BUILDFLAG(IS_ANDROID)
+    if (argc > 0 && argv[0]) {
+      program_path = FilePath(argv[0]).BaseName();
+      // Iterate through argv to check for renderer process type.
+      for (int i = 1; i < argc; ++i) {
+          std::string_view arg_view(argv[i]);
+          if (arg_view == "--type=renderer" || arg_view == "--process-type=renderer") {
+              is_renderer_process = true;
+              break;
+          }
+      }
+    }
+#else
+#error Unsupported platform
+#endif
+
+    bool is_browser_or_renderer = false;
+#if BUILDFLAG(IS_WIN)
+    std::wstring program_name_lower = ToLowerASCII(program_path.RemoveExtension().value());
+    if (program_name_lower == L"chrome" || program_name_lower == L"chromium" || is_renderer_process) {
+      is_browser_or_renderer = true;
+    }
+#else
+    std::string program_name_lower = ToLowerASCII(program_path.RemoveExtension().value());
+    if (program_name_lower == "chrome" || program_name_lower == "chromium" || is_renderer_process) {
+      is_browser_or_renderer = true;
+    }
+#endif
+
+#if BUILDFLAG(IS_WIN)
+    if (is_browser_or_renderer) {
+      current_process_commandline_->ParseFromString(
+          L"chromium --no-first-run "
+          L"--disable-features=ThirdPartyCookies,FieldTrials,Variations,NetworkPrediction,MetricsReporting,CrashReporting,ArticleSuggestions,ContentFeed,Sensors,ProtectedMediaPlaying,BackgroundSync,MediaRouterRemoting,MediaRouter,DrmPreprovisioning,AutofillCommunication,ComponentUpdatePings,Omaha,GaiaAuthCode,PrivacySandbox,PrivacyAwareAnalyticsTrials,OptimizationGuides,OptimizationGuidesFetching "
+          L"--disable-background-networking --no-pings "
+          L"--disable-breakpad --disable-metrics "
+          L"--disable-auto-update "
+          L"--disable-network-time "
+          L"--enable-features=HttpsOnlyMode,PrefetchPrivacyChanges,SplitCacheByNetworkIsolationKey,PartitionConnectionsByNetworkIsolationKey,DoNotTrack,StrictSiteIsolation,StrictOriginIsolation,ReduceAcceptLanguage,ContentSettingsPartitioning,CertificateTransparency,WebRtcAllowProxiedOnly"
+      );
+    } else {
+      current_process_commandline_->ParseFromString(raw_command_line_w);
+    }
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  // SAFETY: required from caller.
-  UNSAFE_BUFFERS(current_process_commandline_->InitFromArgv(argc, argv));
+    if (is_browser_or_renderer) {
+      UNSAFE_BUFFERS(current_process_commandline_->InitFromArgv(dankium_argc, dankium_argv));
+    } else {
+      UNSAFE_BUFFERS(current_process_commandline_->InitFromArgv(argc, argv));
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    if (is_browser_or_renderer) {
+      UNSAFE_BUFFERS(current_process_commandline_->InitFromArgv(dankium_android_argc, dankium_android_argv));
+    } else {
+      UNSAFE_BUFFERS(current_process_commandline_->InitFromArgv(argc, argv));
+    }
 #else
 #error Unsupported platform
 #endif
 
-  return true;
+    return true;
 }
 
 // static
 void CommandLine::Reset() {
-  DCHECK(current_process_commandline_);
-  delete current_process_commandline_;
-  current_process_commandline_ = nullptr;
+    DCHECK(current_process_commandline_);
+    delete current_process_commandline_;
+    current_process_commandline_ = nullptr;
 }
 
 // static
 CommandLine* CommandLine::ForCurrentProcess() {
-  DCHECK(current_process_commandline_);
-  return current_process_commandline_;
+    DCHECK(current_process_commandline_);
+    return current_process_commandline_;
 }
 
 // static
 bool CommandLine::InitializedForCurrentProcess() {
-  return !!current_process_commandline_;
+    return !!current_process_commandline_;
 }
 
 // static
 CommandLine CommandLine::FromArgvWithoutProgram(const StringVector& argv) {
-  CommandLine cmd(NO_PROGRAM);
-  cmd.AppendSwitchesAndArguments(argv);
-  return cmd;
+    CommandLine cmd(NO_PROGRAM);
+    cmd.AppendSwitchesAndArguments(argv);
+    return cmd;
 }
 
 #if BUILDFLAG(IS_WIN)
 // static
 CommandLine CommandLine::FromString(StringViewType command_line) {
-  CommandLine cmd(NO_PROGRAM);
-  cmd.ParseFromString(command_line);
-  return cmd;
+    CommandLine cmd(NO_PROGRAM);
+    cmd.ParseFromString(command_line);
+    return cmd;
 }
 #endif  // BUILDFLAG(IS_WIN)
 
 void CommandLine::InitFromArgv(int argc,
                                const CommandLine::CharType* const* argv) {
-  StringVector new_argv;
-  for (int i = 0; i < argc; ++i) {
-    // SAFETY: required from caller.
-    new_argv.push_back(UNSAFE_BUFFERS(argv[i]));
-  }
-  InitFromArgv(new_argv);
+    StringVector new_argv;
+    for (int i = 0; i < argc; ++i) {
+        // SAFETY: required from caller.
+        new_argv.push_back(UNSAFE_BUFFERS(argv[i]));
+    }
+    InitFromArgv(new_argv);
 }
 
 void CommandLine::InitFromArgv(const StringVector& argv) {
-  argv_ = StringVector(1);
-  switches_.clear();
-  begin_args_ = 1;
-  SetProgram(argv.empty() ? FilePath() : FilePath(argv[0]));
-  if (!argv.empty()) {
-    AppendSwitchesAndArguments(span(argv).subspan<1>());
-  }
+    argv_ = StringVector(1);
+    switches_.clear();
+    begin_args_ = 1;
+    SetProgram(argv.empty() ? FilePath() : FilePath(argv[0]));
+    if (!argv.empty()) {
+        AppendSwitchesAndArguments(span(argv).subspan<1>());
+    }
 }
 
 FilePath CommandLine::GetProgram() const {
-  return FilePath(argv_[0]);
+    return FilePath(argv_[0]);
 }
 
 void CommandLine::SetProgram(const FilePath& program) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Check();
+    sequence_checker_.Check();
 #endif
 #if BUILDFLAG(IS_WIN)
-  argv_[0] = StringType(TrimWhitespace(program.value(), TRIM_ALL));
+    argv_[0] = StringType(TrimWhitespace(program.value(), TRIM_ALL));
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  TrimWhitespaceASCII(program.value(), TRIM_ALL, &argv_[0]);
+    TrimWhitespaceASCII(program.value(), TRIM_ALL, &argv_[0]);
 #else
 #error Unsupported platform
 #endif
 }
 
 bool CommandLine::HasSwitch(std::string_view switch_string) const {
-  CHECK(IsSwitchNameValid(switch_string), base::NotFatalUntil::M134);
-  return Contains(switches_, switch_string);
+    CHECK(IsSwitchNameValid(switch_string), base::NotFatalUntil::M134);
+    return Contains(switches_, switch_string);
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
-  return HasSwitch(std::string_view(switch_constant));
+    return HasSwitch(std::string_view(switch_constant));
 }
 
 std::string CommandLine::GetSwitchValueASCII(
     std::string_view switch_string) const {
-  StringType value = GetSwitchValueNative(switch_string);
+    StringType value = GetSwitchValueNative(switch_string);
 #if BUILDFLAG(IS_WIN)
-  if (!IsStringASCII(base::AsStringPiece16(value))) {
+    if (!IsStringASCII(base::AsStringPiece16(value))) {
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  if (!IsStringASCII(value)) {
+    if (!IsStringASCII(value)) {
 #endif
-    DLOG(WARNING) << "Value of switch (" << switch_string << ") must be ASCII.";
-    return std::string();
-  }
+        DLOG(WARNING) << "Value of switch (" << switch_string << ") must be ASCII.";
+        return std::string();
+    }
 #if BUILDFLAG(IS_WIN)
-  return WideToUTF8(value);
+    return WideToUTF8(value);
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  return value;
+    return value;
 #endif
 }
 
 std::string CommandLine::GetSwitchValueUTF8(
     std::string_view switch_string) const {
-  StringType value = GetSwitchValueNative(switch_string);
+    StringType value = GetSwitchValueNative(switch_string);
 
 #if BUILDFLAG(IS_WIN)
-  const std::string maybe_utf8_value = WideToUTF8(value);
+    const std::string maybe_utf8_value = WideToUTF8(value);
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  const std::string maybe_utf8_value = value;
+    const std::string maybe_utf8_value = value;
 #endif
 
-  if (!IsStringUTF8(maybe_utf8_value)) {
-    DLOG(WARNING) << "Value of switch (" << switch_string << ") is not UTF8.";
-    return {};
-  }
-  return maybe_utf8_value;
+    if (!IsStringUTF8(maybe_utf8_value)) {
+        DLOG(WARNING) << "Value of switch (" << switch_string << ") is not UTF8.";
+        return {};
+    }
+    return maybe_utf8_value;
 }
 
 FilePath CommandLine::GetSwitchValuePath(std::string_view switch_string) const {
-  return FilePath(GetSwitchValueNative(switch_string));
+    return FilePath(GetSwitchValueNative(switch_string));
 }
 
 CommandLine::StringType CommandLine::GetSwitchValueNative(
     std::string_view switch_string) const {
-  CHECK(IsSwitchNameValid(switch_string), base::NotFatalUntil::M134);
+    CHECK(IsSwitchNameValid(switch_string), base::NotFatalUntil::M134);
 
-  auto result = switches_.find(switch_string);
-  return result == switches_.end() ? StringType() : result->second;
+    auto result = switches_.find(switch_string);
+    return result == switches_.end() ? StringType() : result->second;
 }
 
 void CommandLine::AppendSwitch(std::string_view switch_string) {
-  AppendSwitchNative(switch_string, StringType());
+    AppendSwitchNative(switch_string, StringType());
 }
 
 void CommandLine::AppendSwitchPath(std::string_view switch_string,
                                    const FilePath& path) {
-  AppendSwitchNative(switch_string, path.value());
+    AppendSwitchNative(switch_string, path.value());
 }
 
 void CommandLine::AppendSwitchNative(std::string_view switch_string,
                                      CommandLine::StringViewType value) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Check();
+    sequence_checker_.Check();
 #endif
 #if BUILDFLAG(IS_WIN)
-  const std::string switch_key = ToLowerASCII(switch_string);
-  StringType combined_switch_string(UTF8ToWide(switch_key));
+    const std::string switch_key = ToLowerASCII(switch_string);
+    StringType combined_switch_string(UTF8ToWide(switch_key));
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  std::string_view switch_key = switch_string;
-  StringType combined_switch_string(switch_key);
+    std::string_view switch_key = switch_string;
+    StringType combined_switch_string(switch_key);
 #endif
-  size_t prefix_length = GetSwitchPrefixLength(combined_switch_string);
-  auto key = switch_key.substr(prefix_length);
-  if (g_duplicate_switch_handler) {
-    g_duplicate_switch_handler->ResolveDuplicate(key, value,
-                                                 switches_[std::string(key)]);
-  } else {
-    switches_[std::string(key)] = StringType(value);
-  }
-
-  // Preserve existing switch prefixes in |argv_|; only append one if necessary.
-  if (prefix_length == 0) {
-    combined_switch_string.insert(0, kSwitchPrefixes[0].data(),
-                                  kSwitchPrefixes[0].size());
-  }
-  if (!value.empty()) {
-    base::StrAppend(&combined_switch_string, {kSwitchValueSeparator, value});
-  }
-  // Append the switch and update the switches/arguments divider |begin_args_|.
-  argv_.insert(argv_.begin() + begin_args_, combined_switch_string);
-  begin_args_ = (CheckedNumeric(begin_args_) + 1).ValueOrDie();
+    size_t prefix_length = GetSwitchPrefixLength(combined_switch_string);
+    auto key = switch_key.substr(prefix_length);
+    if (g_duplicate_switch_handler) {
+        g_duplicate_switch_handler->ResolveDuplicate(key, value,
+                                                     switches_[std::string(key)]);
+    } else {
+        switches_[std::string(key)] = StringType(value);
+    }
+
+    // Preserve existing switch prefixes in |argv_|; only append one if necessary.
+    if (prefix_length == 0) {
+        combined_switch_string.insert(0, kSwitchPrefixes[0].data(),
+                                      kSwitchPrefixes[0].size());
+    }
+    if (!value.empty()) {
+        base::StrAppend(&combined_switch_string, {kSwitchValueSeparator, value});
+    }
+    // Append the switch and update the switches/arguments divider |begin_args_|.
+    argv_.insert(argv_.begin() + begin_args_, combined_switch_string);
+    begin_args_ = (CheckedNumeric(begin_args_) + 1).ValueOrDie();
 }
 
 void CommandLine::AppendSwitchASCII(std::string_view switch_string,
                                     std::string_view value_string) {
-  AppendSwitchUTF8(switch_string, value_string);
+    AppendSwitchUTF8(switch_string, value_string);
 }
 
 void CommandLine::AppendSwitchUTF8(std::string_view switch_string,
                                    std::string_view value_string) {
-  DCHECK(IsStringUTF8(value_string))
-      << "Switch (" << switch_string << ") value (" << value_string
-      << ") is not UTF8.";
+    DCHECK(IsStringUTF8(value_string))
+        << "Switch (" << switch_string << ") value (" << value_string
+        << ") is not UTF8.";
 #if BUILDFLAG(IS_WIN)
-  AppendSwitchNative(switch_string, UTF8ToWide(value_string));
+    AppendSwitchNative(switch_string, UTF8ToWide(value_string));
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  AppendSwitchNative(switch_string, value_string);
+    AppendSwitchNative(switch_string, value_string);
 #else
 #error Unsupported platform
 #endif
@@ -471,259 +566,259 @@ void CommandLine::AppendSwitchUTF8(std::string_view switch_string,
 
 void CommandLine::RemoveSwitch(std::string_view switch_key_without_prefix) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Check();
+    sequence_checker_.Check();
 #endif
-  CHECK(IsSwitchNameValid(switch_key_without_prefix),
-        base::NotFatalUntil::M134);
+    CHECK(IsSwitchNameValid(switch_key_without_prefix),
+          base::NotFatalUntil::M134);
 
 #if BUILDFLAG(IS_WIN)
-  StringType switch_key_native = UTF8ToWide(switch_key_without_prefix);
+    StringType switch_key_native = UTF8ToWide(switch_key_without_prefix);
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  StringType switch_key_native(switch_key_without_prefix);
+    StringType switch_key_native(switch_key_without_prefix);
 #endif
 
-  DCHECK_EQ(0u, GetSwitchPrefixLength(switch_key_native));
-  auto it = switches_.find(switch_key_without_prefix);
-  if (it == switches_.end()) {
-    return;
-  }
-  switches_.erase(it);
-  // Also erase from the switches section of |argv_| and update |begin_args_|
-  // accordingly.
-  // Switches in |argv_| have indices [1, begin_args_).
-  auto argv_switches_begin = argv_.begin() + 1;
-  auto argv_switches_end = argv_.begin() + begin_args_;
-  DCHECK(argv_switches_begin <= argv_switches_end);
-  DCHECK(argv_switches_end <= argv_.end());
-  auto expell = std::remove_if(argv_switches_begin, argv_switches_end,
-                               [&switch_key_native](const StringType& arg) {
-                                 return IsSwitchWithKey(arg, switch_key_native);
-                               });
-  if (expell == argv_switches_end) {
-    NOTREACHED();
-  }
-  begin_args_ -= argv_switches_end - expell;
-  argv_.erase(expell, argv_switches_end);
+    DCHECK_EQ(0u, GetSwitchPrefixLength(switch_key_native));
+    auto it = switches_.find(switch_key_without_prefix);
+    if (it == switches_.end()) {
+        return;
+    }
+    switches_.erase(it);
+    // Also erase from the switches section of |argv_| and update |begin_args_|
+    // accordingly.
+    // Switches in |argv_| have indices [1, begin_args_).
+    auto argv_switches_begin = argv_.begin() + 1;
+    auto argv_switches_end = argv_.begin() + begin_args_;
+    DCHECK(argv_switches_begin <= argv_switches_end);
+    DCHECK(argv_switches_end <= argv_.end());
+    auto expell = std::remove_if(argv_switches_begin, argv_switches_end,
+                                 [&switch_key_native](const StringType& arg) {
+                                     return IsSwitchWithKey(arg, switch_key_native);
+                                 });
+    if (expell == argv_switches_end) {
+        NOTREACHED();
+    }
+    begin_args_ -= argv_switches_end - expell;
+    argv_.erase(expell, argv_switches_end);
 }
 
 void CommandLine::CopySwitchesFrom(const CommandLine& source,
                                    span<const char* const> switches) {
-  for (const char* entry : switches) {
-    if (source.HasSwitch(entry)) {
-      AppendSwitchNative(entry, source.GetSwitchValueNative(entry));
+    for (const char* entry : switches) {
+        if (source.HasSwitch(entry)) {
+            AppendSwitchNative(entry, source.GetSwitchValueNative(entry));
+        }
     }
-  }
 }
 
 CommandLine::StringVector CommandLine::GetArgs() const {
-  // Gather all arguments after the last switch (may include kSwitchTerminator).
-  StringVector args(argv_.begin() + begin_args_, argv_.end());
-  // Erase only the first kSwitchTerminator (maybe "--" is a legitimate page?)
-  auto switch_terminator = std::ranges::find(args, kSwitchTerminator);
-  if (switch_terminator != args.end()) {
-    args.erase(switch_terminator);
-  }
-  return args;
+    // Gather all arguments after the last switch (may include kSwitchTerminator).
+    StringVector args(argv_.begin() + begin_args_, argv_.end());
+    // Erase only the first kSwitchTerminator (maybe "--" is a legitimate page?)
+    auto switch_terminator = std::ranges::find(args, kSwitchTerminator);
+    if (switch_terminator != args.end()) {
+        args.erase(switch_terminator);
+    }
+    return args;
 }
 
 void CommandLine::AppendArg(std::string_view value) {
 #if BUILDFLAG(IS_WIN)
-  DCHECK(IsStringUTF8(value));
-  AppendArgNative(UTF8ToWide(value));
+    DCHECK(IsStringUTF8(value));
+    AppendArgNative(UTF8ToWide(value));
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-  AppendArgNative(value);
+    AppendArgNative(value);
 #else
 #error Unsupported platform
 #endif
 }
 
 void CommandLine::AppendArgPath(const FilePath& path) {
-  AppendArgNative(path.value());
+    AppendArgNative(path.value());
 }
 
 void CommandLine::AppendArgNative(StringViewType value) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Check();
+    sequence_checker_.Check();
 #endif
-  argv_.emplace_back(value);
+    argv_.emplace_back(value);
 }
 
 void CommandLine::AppendArguments(const CommandLine& other,
                                   bool include_program) {
-  if (include_program) {
-    SetProgram(other.GetProgram());
-  }
-  if (!other.argv().empty()) {
-    AppendSwitchesAndArguments(span(other.argv()).subspan<1>());
-  }
+    if (include_program) {
+        SetProgram(other.GetProgram());
+    }
+    if (!other.argv().empty()) {
+        AppendSwitchesAndArguments(span(other.argv()).subspan<1>());
+    }
 }
 
 void CommandLine::PrependWrapper(StringViewType wrapper) {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Check();
+    sequence_checker_.Check();
 #endif
-  if (wrapper.empty()) {
-    return;
-  }
-  // Split the wrapper command based on whitespace (with quoting).
-  // StringViewType does not currently work directly with StringTokenizerT.
-  using CommandLineTokenizer =
-      StringTokenizerT<StringType, StringType::const_iterator>;
-  StringType wrapper_string(wrapper);
-  CommandLineTokenizer tokenizer(wrapper_string, FILE_PATH_LITERAL(" "));
-  tokenizer.set_quote_chars(FILE_PATH_LITERAL("'\""));
-  std::vector<StringType> wrapper_argv;
-  while (std::optional<StringViewType> token = tokenizer.GetNextTokenView()) {
-    wrapper_argv.emplace_back(token.value());
-  }
-
-  // Prepend the wrapper and update the switches/arguments |begin_args_|.
-  argv_.insert(argv_.begin(), wrapper_argv.begin(), wrapper_argv.end());
-  begin_args_ += wrapper_argv.size();
+    if (wrapper.empty()) {
+        return;
+    }
+    // Split the wrapper command based on whitespace (with quoting).
+    // StringViewType does not currently work directly with StringTokenizerT.
+    using CommandLineTokenizer =
+        StringTokenizerT<StringType, StringType::const_iterator>;
+    StringType wrapper_string(wrapper);
+    CommandLineTokenizer tokenizer(wrapper_string, FILE_PATH_LITERAL(" "));
+    tokenizer.set_quote_chars(FILE_PATH_LITERAL("'\""));
+    std::vector<StringType> wrapper_argv;
+    while (std::optional<StringViewType> token = tokenizer.GetNextTokenView()) {
+        wrapper_argv.emplace_back(token.value());
+    }
+
+    // Prepend the wrapper and update the switches/arguments |begin_args_|.
+    argv_.insert(argv_.begin(), wrapper_argv.begin(), wrapper_argv.end());
+    begin_args_ += wrapper_argv.size();
 }
 
 #if BUILDFLAG(IS_WIN)
 void CommandLine::ParseFromString(StringViewType command_line) {
-  command_line = TrimWhitespace(command_line, TRIM_ALL);
-  if (command_line.empty()) {
-    return;
-  }
-  raw_command_line_string_ = command_line;
-
-  int num_args = 0;
-  wchar_t** args = NULL;
-  // When calling CommandLineToArgvW, use the apiset if available.
-  // Doing so will bypass loading shell32.dll on Windows.
-  HMODULE downlevel_shell32_dll =
-      ::LoadLibraryEx(L"api-ms-win-downlevel-shell32-l1-1-0.dll", nullptr,
-                      LOAD_LIBRARY_SEARCH_SYSTEM32);
-  if (downlevel_shell32_dll) {
-    auto command_line_to_argv_w_proc =
-        reinterpret_cast<decltype(::CommandLineToArgvW)*>(
-            ::GetProcAddress(downlevel_shell32_dll, "CommandLineToArgvW"));
-    if (command_line_to_argv_w_proc) {
-      args = command_line_to_argv_w_proc(command_line.data(), &num_args);
-    }
-  } else {
-    // Since the apiset is not available, allow the delayload of shell32.dll
-    // to take place.
-    args = ::CommandLineToArgvW(command_line.data(), &num_args);
-  }
-
-  DPLOG_IF(FATAL, !args) << "CommandLineToArgvW failed on command line: "
-                         << command_line;
-  StringVector argv(args, UNSAFE_TODO(args + num_args));
-  InitFromArgv(argv);
-  raw_command_line_string_ = StringViewType();
-  LocalFree(args);
-
-  if (downlevel_shell32_dll) {
-    ::FreeLibrary(downlevel_shell32_dll);
-  }
+    command_line = TrimWhitespace(command_line, TRIM_ALL);
+    if (command_line.empty()) {
+        return;
+    }
+    raw_command_line_string_ = command_line;
+
+    int num_args = 0;
+    wchar_t** args = NULL;
+    // When calling CommandLineToArgvW, use the apiset if available.
+    // Doing so will bypass loading shell32.dll on Windows.
+    HMODULE downlevel_shell32_dll =
+        ::LoadLibraryEx(L"api-ms-win-downlevel-shell32-l1-1-0.dll", nullptr,
+                        LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (downlevel_shell32_dll) {
+        auto command_line_to_argv_w_proc =
+            reinterpret_cast<decltype(::CommandLineToArgvW)*>(
+                ::GetProcAddress(downlevel_shell32_dll, "CommandLineToArgvW"));
+        if (command_line_to_argv_w_proc) {
+            args = command_line_to_argv_w_proc(command_line.data(), &num_args);
+        }
+    } else {
+        // Since the apiset is not available, allow the delayload of shell32.dll
+        // to take place.
+        args = ::CommandLineToArgvW(command_line.data(), &num_args);
+    }
+
+    DPLOG_IF(FATAL, !args) << "CommandLineToArgvW failed on command line: "
+                           << command_line;
+    StringVector argv(args, UNSAFE_TODO(args + num_args));
+    InitFromArgv(argv);
+    raw_command_line_string_ = StringViewType();
+    LocalFree(args);
+
+    if (downlevel_shell32_dll) {
+        ::FreeLibrary(downlevel_shell32_dll);
+    }
 }
 
 #endif  // BUILDFLAG(IS_WIN)
 
 void CommandLine::AppendSwitchesAndArguments(span<const StringType> argv) {
-  bool parse_switches = true;
+    bool parse_switches = true;
 #if BUILDFLAG(IS_WIN)
-  const bool is_parsed_from_string = !raw_command_line_string_.empty();
+    const bool is_parsed_from_string = !raw_command_line_string_.empty();
 #endif
-  for (StringType arg : argv) {
+    for (StringType arg : argv) {
 #if BUILDFLAG(IS_WIN)
-    arg = CommandLine::StringType(TrimWhitespace(arg, TRIM_ALL));
+        arg = CommandLine::StringType(TrimWhitespace(arg, TRIM_ALL));
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-    TrimWhitespaceASCII(arg, TRIM_ALL, &arg);
+        TrimWhitespaceASCII(arg, TRIM_ALL, &arg);
 #endif
 
-    CommandLine::StringType switch_string;
-    CommandLine::StringType switch_value;
-    parse_switches &= (arg != kSwitchTerminator);
-    if (parse_switches && IsSwitch(arg, &switch_string, &switch_value)) {
+        CommandLine::StringType switch_string;
+        CommandLine::StringType switch_value;
+        parse_switches &= (arg != kSwitchTerminator);
+        if (parse_switches && IsSwitch(arg, &switch_string, &switch_value)) {
 #if BUILDFLAG(IS_WIN)
-      if (is_parsed_from_string &&
-          IsSwitchWithKey(switch_string, kSingleArgument)) {
-        ParseAsSingleArgument(switch_string);
-        return;
-      }
-      AppendSwitchNative(WideToUTF8(switch_string), switch_value);
+            if (is_parsed_from_string &&
+                IsSwitchWithKey(switch_string, kSingleArgument)) {
+                ParseAsSingleArgument(switch_string);
+                return;
+            }
+            AppendSwitchNative(WideToUTF8(switch_string), switch_value);
 #elif BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
-      AppendSwitchNative(switch_string, switch_value);
+            AppendSwitchNative(switch_string, switch_value);
 #else
 #error Unsupported platform
 #endif
-    } else {
-      AppendArgNative(arg);
+        } else {
+            AppendArgNative(arg);
+        }
     }
-  }
 }
 
 CommandLine::StringType CommandLine::GetArgumentsStringInternal(
     bool allow_unsafe_insert_sequences) const {
-  StringType params;
-  // Append switches and arguments.
-  bool parse_switches = true;
+    StringType params;
+    // Append switches and arguments.
+    bool parse_switches = true;
 #if BUILDFLAG(IS_WIN)
-  bool appended_single_argument_switch = false;
+    bool appended_single_argument_switch = false;
 #endif
 
-  for (size_t i = 1; i < argv_.size(); ++i) {
-    StringType arg = argv_[i];
-    StringType switch_string;
-    StringType switch_value;
-    parse_switches &= arg != kSwitchTerminator;
-    if (i > 1) {
-      params.append(FILE_PATH_LITERAL(" "));
-    }
-    if (parse_switches && IsSwitch(arg, &switch_string, &switch_value)) {
-      params.append(switch_string);
-      if (!switch_value.empty()) {
+    for (size_t i = 1; i < argv_.size(); ++i) {
+        StringType arg = argv_[i];
+        StringType switch_string;
+        StringType switch_value;
+        parse_switches &= arg != kSwitchTerminator;
+        if (i > 1) {
+            params.append(FILE_PATH_LITERAL(" "));
+        }
+        if (parse_switches && IsSwitch(arg, &switch_string, &switch_value)) {
+            params.append(switch_string);
+            if (!switch_value.empty()) {
 #if BUILDFLAG(IS_WIN)
-        switch_value = QuoteForCommandLineToArgvWInternal(
-            switch_value, allow_unsafe_insert_sequences);
+                switch_value = QuoteForCommandLineToArgvWInternal(
+                    switch_value, allow_unsafe_insert_sequences);
 #endif
-        params.append(kSwitchValueSeparator + switch_value);
-      }
-    } else {
+                params.append(kSwitchValueSeparator + switch_value);
+            }
+        } else {
 #if BUILDFLAG(IS_WIN)
-      if (has_single_argument_switch_) {
-        // Check that we don't have multiple arguments when
-        // `has_single_argument_switch_` is true.
-        DCHECK(!appended_single_argument_switch);
-        appended_single_argument_switch = true;
-        params.append(base::StrCat(
-            {kSwitchPrefixes[0], kSingleArgument, FILE_PATH_LITERAL(" ")}));
-      } else {
-        arg = QuoteForCommandLineToArgvWInternal(arg,
-                                                 allow_unsafe_insert_sequences);
-      }
+            if (has_single_argument_switch_) {
+                // Check that we don't have multiple arguments when
+                // `has_single_argument_switch_` is true.
+                DCHECK(!appended_single_argument_switch);
+                appended_single_argument_switch = true;
+                params.append(base::StrCat(
+                    {kSwitchPrefixes[0], kSingleArgument, FILE_PATH_LITERAL(" ")}));
+            } else {
+                arg = QuoteForCommandLineToArgvWInternal(arg,
+                                                         allow_unsafe_insert_sequences);
+            }
 #endif
-      params.append(arg);
+            params.append(arg);
+        }
     }
-  }
-  return params;
+    return params;
 }
 
 CommandLine::StringType CommandLine::GetCommandLineString() const {
-  StringType string(argv_[0]);
+    StringType string(argv_[0]);
 #if BUILDFLAG(IS_WIN)
-  string = QuoteForCommandLineToArgvWInternal(
-      string,
-      /*allow_unsafe_insert_sequences=*/false);
+    string = QuoteForCommandLineToArgvWInternal(
+        string,
+        /*allow_unsafe_insert_sequences=*/false);
 #endif
-  StringType params(GetArgumentsString());
-  if (!params.empty()) {
-    string.append(FILE_PATH_LITERAL(" "));
-    string.append(params);
-  }
-  return string;
+    StringType params(GetArgumentsString());
+    if (!params.empty()) {
+        string.append(FILE_PATH_LITERAL(" "));
+        string.append(params);
+    }
+    return string;
 }
 
 #if BUILDFLAG(IS_WIN)
 // static
 std::wstring CommandLine::QuoteForCommandLineToArgvW(const std::wstring& arg) {
-  return QuoteForCommandLineToArgvWInternal(
-      arg, /*allow_unsafe_insert_sequences=*/false);
+    return QuoteForCommandLineToArgvWInternal(
+        arg, /*allow_unsafe_insert_sequences=*/false);
 }
 
 // NOTE: this function is used to set Chrome's open command in the registry
@@ -734,67 +829,67 @@ std::wstring CommandLine::QuoteForCommandLineToArgvW(const std::wstring& arg) {
 // update, when parsing command lines for other channels, when uninstalling web
 // applications installed using the old syntax, etc.
 CommandLine::StringType CommandLine::GetCommandLineStringForShell() const {
-  DCHECK(GetArgs().empty());
-  StringType command_line_string = GetCommandLineString();
-  return command_line_string + FILE_PATH_LITERAL(" ") +
-         StringType(kSwitchPrefixes[0]) + kSingleArgument +
-         FILE_PATH_LITERAL(" %1");
+    DCHECK(GetArgs().empty());
+    StringType command_line_string = GetCommandLineString();
+    return command_line_string + FILE_PATH_LITERAL(" ") +
+           StringType(kSwitchPrefixes[0]) + kSingleArgument +
+           FILE_PATH_LITERAL(" %1");
 }
 
 CommandLine::StringType
 CommandLine::GetCommandLineStringWithUnsafeInsertSequences() const {
-  StringType string(argv_[0]);
-  string = QuoteForCommandLineToArgvWInternal(
-      string,
-      /*allow_unsafe_insert_sequences=*/true);
-  StringType params(
-      GetArgumentsStringInternal(/*allow_unsafe_insert_sequences=*/true));
-  if (!params.empty()) {
-    string.append(FILE_PATH_LITERAL(" "));
-    string.append(params);
-  }
-  return string;
+    StringType string(argv_[0]);
+    string = QuoteForCommandLineToArgvWInternal(
+        string,
+        /*allow_unsafe_insert_sequences=*/true);
+    StringType params(
+        GetArgumentsStringInternal(/*allow_unsafe_insert_sequences=*/true));
+    if (!params.empty()) {
+        string.append(FILE_PATH_LITERAL(" "));
+        string.append(params);
+    }
+    return string;
 }
 #endif  // BUILDFLAG(IS_WIN)
 
 CommandLine::StringType CommandLine::GetArgumentsString() const {
-  return GetArgumentsStringInternal(/*allow_unsafe_insert_sequences=*/false);
+    return GetArgumentsStringInternal(/*allow_unsafe_insert_sequences=*/false);
 }
 
 #if BUILDFLAG(IS_WIN)
 void CommandLine::ParseAsSingleArgument(
     const CommandLine::StringType& single_arg_switch) {
-  DCHECK(!raw_command_line_string_.empty());
-
-  // Remove any previously parsed arguments.
-  argv_.resize(static_cast<size_t>(begin_args_));
-
-  // Locate "--single-argument" in the process's raw command line. Results are
-  // unpredictable if "--single-argument" appears as part of a previous
-  // argument or switch.
-  const size_t single_arg_switch_position =
-      raw_command_line_string_.find(single_arg_switch);
-  DCHECK_NE(single_arg_switch_position, StringType::npos);
-
-  // Append the portion of the raw command line that starts one character past
-  // "--single-argument" as the one and only argument, or return if no
-  // argument is present.
-  const size_t arg_position =
-      single_arg_switch_position + single_arg_switch.length() + 1;
-  if (arg_position >= raw_command_line_string_.length()) {
-    return;
-  }
-  has_single_argument_switch_ = true;
-  const StringViewType arg = raw_command_line_string_.substr(arg_position);
-  if (!arg.empty()) {
-    AppendArgNative(arg);
-  }
+    DCHECK(!raw_command_line_string_.empty());
+
+    // Remove any previously parsed arguments.
+    argv_.resize(static_cast<size_t>(begin_args_));
+
+    // Locate "--single-argument" in the process's raw command line. Results are
+    // unpredictable if "--single-argument" appears as part of a previous
+    // argument or switch.
+    const size_t single_arg_switch_position =
+        raw_command_line_string_.find(single_arg_switch);
+    DCHECK_NE(single_arg_switch_position, StringType::npos);
+
+    // Append the portion of the raw command line that starts one character past
+    // "--single-argument" as the one and only argument, or return if no
+    // argument is present.
+    const size_t arg_position =
+        single_arg_switch_position + single_arg_switch.length() + 1;
+    if (arg_position >= raw_command_line_string_.length()) {
+        return;
+    }
+    has_single_argument_switch_ = true;
+    const StringViewType arg = raw_command_line_string_.substr(arg_position);
+    if (!arg.empty()) {
+        AppendArgNative(arg);
+    }
 }
 #endif  // BUILDFLAG(IS_WIN)
 
 void CommandLine::DetachFromCurrentSequence() {
 #if BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
-  sequence_checker_.Detach();
+    sequence_checker_.Detach();
 #endif  // BUILDFLAG(ENABLE_COMMANDLINE_SEQUENCE_CHECKS)
 }
 
-- 
2.43.0


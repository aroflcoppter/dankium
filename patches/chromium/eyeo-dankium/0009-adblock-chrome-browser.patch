From 2a1bbacbfea3f0d6684a1a56a3616b4e703309df Mon Sep 17 00:00:00 2001
From: vanilla-chromium-builder <project_26591639_bot@noreply.gitlab.com>
Date: Thu, 22 May 2025 15:50:31 +0000
Subject: [PATCH] adblock chrome browser

---
 chrome/browser/BUILD.gn                       |  15 +
 .../android/adblock/tab_id_translator_jni.cc  |  41 +
 chrome/browser/chrome_browser_main.cc         |   7 +
 .../client_hints/client_hints_browsertest.cc  |  11 +-
 .../browser/devtools/devtools_browsertest.cc  |   3 +-
 chrome/browser/extensions/BUILD.gn            |  18 +
 chrome/browser/extensions/api/BUILD.gn        |   4 +
 .../adblock_private/adblock_private_api.cc    | 693 ++++++++++++++
 .../api/adblock_private/adblock_private_api.h | 360 ++++++++
 .../adblock_private_apitest.cc                | 174 ++++
 .../adblock_private_apitest_backgroundpage.cc | 398 ++++++++
 .../adblock_private_apitest_base.cc           | 103 +++
 .../adblock_private_apitest_base.h            |  62 ++
 ...e_filter_lists_with_http_server_apitest.cc | 188 ++++
 ...browser_context_keyed_service_factories.cc |   6 +
 .../eyeo_dev_tools_private_api.cc             | 447 +++++++++
 .../eyeo_dev_tools_private_api.h              | 173 ++++
 .../eyeo_dev_tools_private_apitest.cc         | 256 ++++++
 .../eyeo_filtering_private_api.cc             | 855 ++++++++++++++++++
 .../eyeo_filtering_private_api.h              | 392 ++++++++
 .../eyeo_filtering_private_apitest.cc         | 172 ++++
 .../extension_function_registration_test.cc   |  11 +
 chrome/browser/net/errorpage_browsertest.cc   |   8 +
 ..._page_load_metrics_observer_browsertest.cc |   7 +-
 chrome/browser/preferences/BUILD.gn           |   4 +
 chrome/browser/prefs/browser_prefs.cc         |   2 +
 .../prefs/chrome_pref_service_factory.cc      |  11 +
 ...hrome_browser_main_extra_parts_profiles.cc |  22 +
 .../profile_keyed_service_browsertest.cc      |  29 +
 chrome/browser/resources/BUILD.gn             |   5 +
 .../safe_browsing_blocking_page_test.cc       |   7 +-
 .../sessions/session_restore_browsertest.cc   |  10 +-
 ...subresource_filter_browser_test_harness.cc |   8 +-
 chrome/browser/ui/BUILD.gn                    |  12 +
 chrome/browser/ui/prefs/pref_watcher.cc       |  13 +
 chrome/browser/ui/tab_helpers.cc              |  13 +
 36 files changed, 4533 insertions(+), 7 deletions(-)
 create mode 100644 chrome/browser/android/adblock/tab_id_translator_jni.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_api.h
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h
 create mode 100644 chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_apitest.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index efb9b948aca15..0a2ee7cbcd360 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//base/allocator/allocator.gni")
 import("//build/buildflag_header.gni")
@@ -174,6 +177,10 @@ static_library("browser") {
     "accessibility/page_colors_factory.h",
     "accessibility/prefers_default_scrollbar_styles_prefs.cc",
     "accessibility/prefers_default_scrollbar_styles_prefs.h",
+    "adblock/adblock_chrome_content_browser_client.cc",
+    "adblock/adblock_chrome_content_browser_client.h",
+    "affiliations/affiliation_service_factory.cc",
+    "affiliations/affiliation_service_factory.h",
     "after_startup_task_utils.cc",
     "after_startup_task_utils.h",
     "app_mode/app_mode_utils.cc",
@@ -2082,6 +2089,7 @@ static_library("browser") {
     "//chrome/installer/util:with_no_strings",
     "//chrome/services/speech/buildflags",
     "//components/application_locale_storage",
+    "//components/adblock/content:browser",
     "//components/assist_ranker",
     "//components/autofill/content/browser",
     "//components/autofill/core/browser",
@@ -3321,6 +3329,11 @@ static_library("browser") {
       "touch_to_fill/password_manager/touch_to_fill_controller_webauthn_delegate.h",
     ]
 
+    ### Android API module start
+    sources += [ "android/adblock/tab_id_translator_jni.cc" ]
+
+    ### Android API module end
+
     deps += [
       ":delta_file_proto",
       ":profile_token",
@@ -8476,6 +8489,8 @@ static_library("browser_public_dependencies") {
     "//chrome/common/compose:mojo_bindings",
     "//chrome/services/file_util/public/mojom",
     "//components/account_id",
+    "//components/adblock/content:browser",
+    "//components/adblock/content/renderer",
     "//components/autofill/content/browser",
     "//components/autofill/core/browser",
     "//components/commerce/core/product_specifications:product_specifications",
diff --git a/chrome/browser/android/adblock/tab_id_translator_jni.cc b/chrome/browser/android/adblock/tab_id_translator_jni.cc
new file mode 100644
index 0000000000000..731aa7bd3acde
--- /dev/null
+++ b/chrome/browser/android/adblock/tab_id_translator_jni.cc
@@ -0,0 +1,41 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/android/chrome_jni_headers/TabIdTranslator_jni.h"
+#include "chrome/browser/android/tab_android.h"
+#include "content/public/browser/web_contents.h"
+
+namespace {
+constexpr int kNoTabId = -1;
+}
+
+static jint JNI_TabIdTranslator_FromRenderFrameHostId(JNIEnv* env,
+                                                      jint render_process_id,
+                                                      jint render_frame_id) {
+  auto* web_contents = content::WebContents::FromRenderFrameHost(
+      content::RenderFrameHost::FromID(render_process_id, render_frame_id));
+  if (!web_contents) {
+    return kNoTabId;
+  }
+
+  auto* tab = TabAndroid::FromWebContents(web_contents);
+  if (!tab) {
+    return kNoTabId;
+  }
+
+  return tab->GetAndroidId();
+}
diff --git a/chrome/browser/chrome_browser_main.cc b/chrome/browser/chrome_browser_main.cc
index ee9e6e9208043..a4b3e66aa2921 100644
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/chrome_browser_main.h"
 
@@ -77,6 +81,7 @@
 #include "chrome/grit/branded_strings.h"
 #include "chrome/grit/generated_resources.h"
 #include "chrome/installer/util/google_update_settings.h"
+#include "components/adblock/content/browser/adblock_web_ui_controller_factory.h"
 #include "components/color/color_mixers.h"
 #include "components/device_event_log/device_event_log.h"
 #include "components/embedder_support/origin_trials/component_updater_utils.h"
@@ -1537,6 +1542,8 @@ int ChromeBrowserMainParts::PreMainMessageLoopRunImpl() {
   // called inside PostProfileInit.
   content::WebUIControllerFactory::RegisterFactory(
       ChromeWebUIControllerFactory::GetInstance());
+  content::WebUIControllerFactory::RegisterFactory(
+      adblock::AdblockWebUIControllerFactory::GetInstance());
   RegisterChromeWebUIConfigs();
   RegisterChromeUntrustedWebUIConfigs();
 
diff --git a/chrome/browser/client_hints/client_hints_browsertest.cc b/chrome/browser/client_hints/client_hints_browsertest.cc
index cac78ae41abef..02809e2a1829f 100644
--- a/chrome/browser/client_hints/client_hints_browsertest.cc
+++ b/chrome/browser/client_hints/client_hints_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "components/client_hints/common/client_hints.h"
 
@@ -661,7 +665,12 @@ class ClientHintsBrowserTest : public policy::PolicyTest {
     std::unique_ptr<base::FeatureList> feature_list(new base::FeatureList);
     // Force-enable the ClientHintsFormFactors feature, so that the header is
     // represented in the various header counts.
-    feature_list->InitFromCommandLine(kDefaultFeatures, "");
+    feature_list->InitFromCommandLine(
+        kDefaultFeatures,
+        // Disabling AdblockPlus because the async implementation of
+        // AdblockURLLoaderThrottle::WillStartRequest confuses
+        // ThirdPartyURLLoaderInterceptor.
+        "AdblockPlus");
     scoped_feature_list.InitWithFeatureList(std::move(feature_list));
   }
 
diff --git a/chrome/browser/devtools/devtools_browsertest.cc b/chrome/browser/devtools/devtools_browsertest.cc
index 04a710b9b7699..48711d0510c83 100644
--- a/chrome/browser/devtools/devtools_browsertest.cc
+++ b/chrome/browser/devtools/devtools_browsertest.cc
@@ -3155,8 +3155,9 @@ IN_PROC_BROWSER_TEST_F(DevToolsTest,
 #define MAYBE_TestRawHeadersWithRedirectAndHSTS \
   DISABLED_TestRawHeadersWithRedirectAndHSTS
 #else
+// TODO DPD-3223. Re-enable the test.
 #define MAYBE_TestRawHeadersWithRedirectAndHSTS \
-  TestRawHeadersWithRedirectAndHSTS
+  DISABLED_TestRawHeadersWithRedirectAndHSTS
 #endif
 IN_PROC_BROWSER_TEST_F(DevToolsTest, MAYBE_TestRawHeadersWithRedirectAndHSTS) {
   net::EmbeddedTestServer https_test_server(
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 2a16c69d04eca..fd6b0fecab506 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/chromebox_for_meetings/buildflags.gni")
 import("//build/config/chromeos/ui_mode.gni")
@@ -424,6 +427,7 @@ source_set("extensions") {
     "window_controller_list.h",
     "window_controller_list_observer.h",
   ]
+
   configs += [
     "//build/config:precompiled_headers",
     "//build/config/compiler:wexit_time_destructors",
@@ -776,6 +780,20 @@ source_set("extensions") {
       ]
     }
 
+    ### Extensions API module start
+    sources += [
+      "api/adblock_private/adblock_private_api.cc",
+      "api/adblock_private/adblock_private_api.h",
+      "api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.cc",
+      "api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h",
+      "api/eyeo_filtering_private/eyeo_filtering_private_api.cc",
+      "api/eyeo_filtering_private/eyeo_filtering_private_api.h",
+    ]
+
+    deps += [ "//components/adblock/content:browser" ]
+
+    ### Extensions API module end
+
     # Chrome OS does not support Native Messaging policies.
     if (!is_chromeos) {
       sources += [
diff --git a/chrome/browser/extensions/api/BUILD.gn b/chrome/browser/extensions/api/BUILD.gn
index 5fbe9340ccb8a..90356ecac69de 100644
--- a/chrome/browser/extensions/api/BUILD.gn
+++ b/chrome/browser/extensions/api/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2018 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//chrome/common/extensions/api/api_sources.gni")
 import("//chrome/common/features.gni")
@@ -138,6 +141,7 @@ function_registration("api_registration") {
     # include generated headers from these targets.
     # TODO(brettw) this should be made unnecessary if possible.
     "//chrome/common/extensions/api",
+    "//components/adblock/content:browser",
     "//components/sync",
     "//skia",
     "//third_party/metrics_proto",
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
new file mode 100644
index 0000000000000..b0ce7b8b7ca4e
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
@@ -0,0 +1,693 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_api.h"
+
+#include "base/containers/flat_map.h"
+#include "base/i18n/time_formatting.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/common/adblock_utils.h"
+#include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/session_stats.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/prefs/pref_service.h"
+#include "components/sessions/core/session_id.h"
+#include "content/public/browser/web_contents.h"
+#include "url/gurl.h"
+
+namespace extensions {
+
+namespace {
+
+enum class SubscriptionAction { kInstall, kUninstall };
+
+content::BrowserContext* GetOriginalBrowserContext(
+    content::BrowserContext* browser_context) {
+  return Profile::FromBrowserContext(browser_context)->GetOriginalProfile();
+}
+
+adblock::FilteringConfiguration* GetAdblockConfiguration(
+    content::BrowserContext* browser_context) {
+  auto* adblock_configuration =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context))
+          ->GetFilteringConfiguration(
+              adblock::kAdblockFilteringConfigurationName);
+  DCHECK(adblock_configuration)
+      << "adblock_private expects \"adblock\" configuration";
+  return adblock_configuration;
+}
+
+std::string RunSubscriptionAction(SubscriptionAction action,
+                                  content::BrowserContext* browser_context,
+                                  const GURL& url) {
+  if (!url.is_valid()) {
+    return "Invalid URL";
+  }
+  auto* adblock_configuration = GetAdblockConfiguration(browser_context);
+  switch (action) {
+    case SubscriptionAction::kInstall:
+      adblock_configuration->AddFilterList(url);
+      break;
+    case SubscriptionAction::kUninstall:
+      adblock_configuration->RemoveFilterList(url);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  return {};
+}
+
+std::vector<api::adblock_private::SessionStatsEntry> CopySessionsStats(
+    const std::map<GURL, long>& source) {
+  std::vector<api::adblock_private::SessionStatsEntry> result;
+  for (auto& entry : source) {
+    api::adblock_private::SessionStatsEntry js_entry;
+    js_entry.url = entry.first.spec();
+    js_entry.count = entry.second;
+    result.emplace_back(std::move(js_entry));
+  }
+  return result;
+}
+
+std::string SubscriptionInstallationStateToString(
+    adblock::Subscription::InstallationState state) {
+  using State = adblock::Subscription::InstallationState;
+  switch (state) {
+    case State::Installed:
+      return "Installed";
+    case State::AutoInstalled:
+      return "AutoInstalled";
+    case State::Preloaded:
+      return "Preloaded";
+    case State::Installing:
+      return "Installing";
+    case State::Unknown:
+      return "Unknown";
+  }
+  return "";
+}
+
+std::vector<api::adblock_private::Subscription> CopySubscriptions(
+    const std::vector<scoped_refptr<adblock::Subscription>>
+        current_subscriptions) {
+  std::vector<api::adblock_private::Subscription> result;
+  for (auto& sub : current_subscriptions) {
+    api::adblock_private::Subscription js_sub;
+    js_sub.url = sub->GetSourceUrl().spec();
+    js_sub.title = sub->GetTitle();
+    js_sub.current_version = sub->GetCurrentVersion();
+    js_sub.installation_state =
+        SubscriptionInstallationStateToString(sub->GetInstallationState());
+    const auto installation_time = sub->GetInstallationTime();
+    js_sub.last_installation_time =
+        installation_time.is_null()
+            ? ""
+            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+    result.emplace_back(std::move(js_sub));
+  }
+  return result;
+}
+
+}  // namespace
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    AdblockPrivateAPI>::DeclareFactoryDependencies() {
+  DependsOn(adblock::SubscriptionServiceFactory::GetInstance());
+  DependsOn(adblock::ResourceClassificationRunnerFactory::GetInstance());
+  DependsOn(adblock::SessionStatsFactory::GetInstance());
+}
+
+// static
+BrowserContextKeyedAPIFactory<AdblockPrivateAPI>*
+AdblockPrivateAPI::GetFactoryInstance() {
+  static base::NoDestructor<BrowserContextKeyedAPIFactory<AdblockPrivateAPI>>
+      instance;
+  return instance.get();
+}
+
+class AdblockPrivateAPI::AdblockAPIEventRouter
+    : public adblock::ResourceClassificationRunner::Observer,
+      public adblock::SubscriptionService::SubscriptionObserver,
+      public adblock::FilteringConfiguration::Observer {
+ public:
+  explicit AdblockAPIEventRouter(content::BrowserContext* context)
+      : context_(GetOriginalBrowserContext(context)) {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->AddObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->AddObserver(this);
+    GetAdblockConfiguration(context_)->AddObserver(this);
+  }
+
+  ~AdblockAPIEventRouter() override {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->RemoveObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->RemoveObserver(this);
+    GetAdblockConfiguration(context_)->RemoveObserver(this);
+  }
+
+  // adblock::ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        adblock::FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        adblock::ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = adblock::utils::ConvertURLs(parent_frame_urls);
+    info.content_type = adblock::ContentTypeToString(content_type);
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnAdBlocked::kEventName,
+          api::adblock_private::OnAdBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnAdAllowed::kEventName,
+          api::adblock_private::OnAdAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{};
+    info.content_type = "";
+
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT, api::adblock_private::OnPageAllowed::kEventName,
+        api::adblock_private::OnPageAllowed::Create(info));
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      adblock::FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{opener_url.spec()};
+    info.content_type = "";
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnPopupBlocked::kEventName,
+          api::adblock_private::OnPopupBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnPopupAllowed::kEventName,
+          api::adblock_private::OnPopupAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::SubscriptionService::SubscriptionObserver:
+  void OnSubscriptionInstalled(const GURL& url) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnSubscriptionUpdated::kEventName,
+        api::adblock_private::OnSubscriptionUpdated::Create(url.spec()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::FilteringConfiguration::Observer:
+  void OnEnabledStateChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnEnabledStateChanged::kEventName,
+        api::adblock_private::OnEnabledStateChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilterListsChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnFilterListsChanged::kEventName,
+        api::adblock_private::OnFilterListsChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnAllowedDomainsChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnAllowedDomainsChanged::kEventName,
+        api::adblock_private::OnAllowedDomainsChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnCustomFiltersChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnCustomFiltersChanged::kEventName,
+        api::adblock_private::OnCustomFiltersChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+ private:
+  api::adblock_private::AdInfo CreateAdInfoObject(
+      const GURL& url,
+      const GURL& subscription,
+      const std::string& configuration_name,
+      content::RenderFrameHost* render_frame_host) {
+    DCHECK(render_frame_host);
+    api::adblock_private::AdInfo info;
+    info.url = url.spec();
+    info.subscription = subscription.spec();
+    info.configuration_name = configuration_name;
+    info.tab_id = api::tabs::TAB_ID_NONE;
+    info.window_id = SessionID::InvalidValue().id();
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (wc) {
+      info.tab_id = ExtensionTabUtil::GetTabId(wc);
+      info.window_id = ExtensionTabUtil::GetWindowIdOfTab(wc);
+    }
+    return info;
+  }
+
+  raw_ptr<content::BrowserContext> context_;
+};
+
+void AdblockPrivateAPI::Shutdown() {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->UnregisterObserver(this);
+  }
+  event_router_.reset();
+}
+
+// static
+AdblockPrivateAPI* AdblockPrivateAPI::Get(content::BrowserContext* context) {
+  return GetFactoryInstance()->Get(context);
+}
+
+AdblockPrivateAPI::AdblockPrivateAPI(content::BrowserContext* context)
+    : context_(context) {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAdAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAdBlocked::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPageAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPopupAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPopupBlocked::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnSubscriptionUpdated::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnEnabledStateChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnFilterListsChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAllowedDomainsChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnCustomFiltersChanged::kEventName);
+  }
+  // Make sure SessionStats is created so it will start collectings stats
+  adblock::SessionStatsFactory::GetForBrowserContext(context);
+}
+
+AdblockPrivateAPI::~AdblockPrivateAPI() = default;
+
+void AdblockPrivateAPI::OnListenerAdded(
+    const extensions::EventListenerInfo& details) {
+  event_router_ =
+      std::make_unique<AdblockPrivateAPI::AdblockAPIEventRouter>(context_);
+  EventRouter::Get(context_)->UnregisterObserver(this);
+}
+
+namespace api {
+
+AdblockPrivateSetEnabledFunction::AdblockPrivateSetEnabledFunction() {}
+
+AdblockPrivateSetEnabledFunction::~AdblockPrivateSetEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateSetEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetEnabled::Params> params =
+      api::adblock_private::SetEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->SetEnabled(params->enabled);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsEnabledFunction::AdblockPrivateIsEnabledFunction() {}
+
+AdblockPrivateIsEnabledFunction::~AdblockPrivateIsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateIsEnabledFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::IsEnabled::Results::Create(
+          adblock_configuration->IsEnabled())));
+}
+
+AdblockPrivateSetAcceptableAdsEnabledFunction::
+    AdblockPrivateSetAcceptableAdsEnabledFunction() {}
+
+AdblockPrivateSetAcceptableAdsEnabledFunction::
+    ~AdblockPrivateSetAcceptableAdsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateSetAcceptableAdsEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetAcceptableAdsEnabled::Params> params =
+      api::adblock_private::SetAcceptableAdsEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  if (params->enabled) {
+    adblock_configuration->AddFilterList(adblock::AcceptableAdsUrl());
+  } else {
+    adblock_configuration->RemoveFilterList(adblock::AcceptableAdsUrl());
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsAcceptableAdsEnabledFunction::
+    AdblockPrivateIsAcceptableAdsEnabledFunction() {}
+
+AdblockPrivateIsAcceptableAdsEnabledFunction::
+    ~AdblockPrivateIsAcceptableAdsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateIsAcceptableAdsEnabledFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::IsAcceptableAdsEnabled::Results::Create(
+          std::ranges::any_of(adblock_configuration->GetFilterLists(),
+                              [&](const auto& url) {
+                                return url == adblock::AcceptableAdsUrl();
+                              }))));
+}
+
+AdblockPrivateSetAutoInstallEnabledFunction::
+    AdblockPrivateSetAutoInstallEnabledFunction() {}
+
+AdblockPrivateSetAutoInstallEnabledFunction::
+    ~AdblockPrivateSetAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateSetAutoInstallEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetAutoInstallEnabled::Params> params =
+      api::adblock_private::SetAutoInstallEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  subscription_service->SetAutoInstallEnabled(params->enabled);
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsAutoInstallEnabledFunction::
+    AdblockPrivateIsAutoInstallEnabledFunction() {}
+
+AdblockPrivateIsAutoInstallEnabledFunction::
+    ~AdblockPrivateIsAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateIsAutoInstallEnabledFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  return RespondNow(
+      ArgumentList(api::adblock_private::IsAutoInstallEnabled::Results::Create(
+          subscription_service->IsAutoInstallEnabled())));
+}
+
+AdblockPrivateGetBuiltInSubscriptionsFunction::
+    AdblockPrivateGetBuiltInSubscriptionsFunction() {}
+
+AdblockPrivateGetBuiltInSubscriptionsFunction::
+    ~AdblockPrivateGetBuiltInSubscriptionsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetBuiltInSubscriptionsFunction::Run() {
+  auto recommended = adblock::config::GetKnownSubscriptions();
+  std::vector<api::adblock_private::BuiltInSubscription> result;
+  for (auto& recommended_one : recommended) {
+    if (recommended_one.ui_visibility ==
+        adblock::SubscriptionUiVisibility::Visible) {
+      api::adblock_private::BuiltInSubscription js_recommended;
+      js_recommended.url = recommended_one.url.spec();
+      js_recommended.title = recommended_one.title;
+      js_recommended.languages = recommended_one.languages;
+      result.emplace_back(std::move(js_recommended));
+    }
+  }
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetBuiltInSubscriptions::Results::Create(result)));
+}
+
+AdblockPrivateInstallSubscriptionFunction::
+    AdblockPrivateInstallSubscriptionFunction() {}
+
+AdblockPrivateInstallSubscriptionFunction::
+    ~AdblockPrivateInstallSubscriptionFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateInstallSubscriptionFunction::Run() {
+  absl::optional<api::adblock_private::InstallSubscription::Params> params =
+      api::adblock_private::InstallSubscription::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(SubscriptionAction::kInstall,
+                            GetOriginalBrowserContext(browser_context()), url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateUninstallSubscriptionFunction::
+    AdblockPrivateUninstallSubscriptionFunction() {}
+
+AdblockPrivateUninstallSubscriptionFunction::
+    ~AdblockPrivateUninstallSubscriptionFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateUninstallSubscriptionFunction::Run() {
+  absl::optional<api::adblock_private::UninstallSubscription::Params> params =
+      api::adblock_private::UninstallSubscription::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(SubscriptionAction::kUninstall,
+                            GetOriginalBrowserContext(browser_context()), url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetInstalledSubscriptionsFunction::
+    AdblockPrivateGetInstalledSubscriptionsFunction() {}
+
+AdblockPrivateGetInstalledSubscriptionsFunction::
+    ~AdblockPrivateGetInstalledSubscriptionsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetInstalledSubscriptionsFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetInstalledSubscriptions::Results::Create(
+          CopySubscriptions(subscription_service->GetCurrentSubscriptions(
+              adblock_configuration)))));
+}
+
+AdblockPrivateAddAllowedDomainFunction::
+    AdblockPrivateAddAllowedDomainFunction() {}
+
+AdblockPrivateAddAllowedDomainFunction::
+    ~AdblockPrivateAddAllowedDomainFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateAddAllowedDomainFunction::Run() {
+  absl::optional<api::adblock_private::AddAllowedDomain::Params> params =
+      api::adblock_private::AddAllowedDomain::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->AddAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateRemoveAllowedDomainFunction::
+    AdblockPrivateRemoveAllowedDomainFunction() {}
+
+AdblockPrivateRemoveAllowedDomainFunction::
+    ~AdblockPrivateRemoveAllowedDomainFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateRemoveAllowedDomainFunction::Run() {
+  absl::optional<api::adblock_private::RemoveAllowedDomain::Params> params =
+      api::adblock_private::RemoveAllowedDomain::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->RemoveAllowedDomain(params->domain);
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetAllowedDomainsFunction::
+    AdblockPrivateGetAllowedDomainsFunction() {}
+
+AdblockPrivateGetAllowedDomainsFunction::
+    ~AdblockPrivateGetAllowedDomainsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetAllowedDomainsFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::GetAllowedDomains::Results::Create(
+          adblock_configuration->GetAllowedDomains())));
+}
+
+AdblockPrivateAddCustomFilterFunction::AdblockPrivateAddCustomFilterFunction() {
+}
+
+AdblockPrivateAddCustomFilterFunction::
+    ~AdblockPrivateAddCustomFilterFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateAddCustomFilterFunction::Run() {
+  absl::optional<api::adblock_private::AddCustomFilter::Params> params =
+      api::adblock_private::AddCustomFilter::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->AddCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateRemoveCustomFilterFunction::
+    AdblockPrivateRemoveCustomFilterFunction() {}
+
+AdblockPrivateRemoveCustomFilterFunction::
+    ~AdblockPrivateRemoveCustomFilterFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetCustomFiltersFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::GetCustomFilters::Results::Create(
+          adblock_configuration->GetCustomFilters())));
+}
+
+AdblockPrivateGetCustomFiltersFunction::
+    AdblockPrivateGetCustomFiltersFunction() {}
+
+AdblockPrivateGetCustomFiltersFunction::
+    ~AdblockPrivateGetCustomFiltersFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateRemoveCustomFilterFunction::Run() {
+  absl::optional<api::adblock_private::RemoveCustomFilter::Params> params =
+      api::adblock_private::RemoveCustomFilter::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->RemoveCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetSessionAllowedAdsCountFunction::
+    AdblockPrivateGetSessionAllowedAdsCountFunction() {}
+
+AdblockPrivateGetSessionAllowedAdsCountFunction::
+    ~AdblockPrivateGetSessionAllowedAdsCountFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetSessionAllowedAdsCountFunction::Run() {
+  auto* session_stats_ = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetSessionAllowedAdsCount::Results::Create(
+          CopySessionsStats(
+              session_stats_->GetSessionAllowedResourcesCount()))));
+}
+
+AdblockPrivateGetSessionBlockedAdsCountFunction::
+    AdblockPrivateGetSessionBlockedAdsCountFunction() {}
+
+AdblockPrivateGetSessionBlockedAdsCountFunction::
+    ~AdblockPrivateGetSessionBlockedAdsCountFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetSessionBlockedAdsCountFunction::Run() {
+  auto* session_stats_ = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetSessionAllowedAdsCount::Results::Create(
+          CopySessionsStats(
+              session_stats_->GetSessionBlockedResourcesCount()))));
+}
+
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.h b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
new file mode 100644
index 0000000000000..a1f1bab92b5cb
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
@@ -0,0 +1,360 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/common/extensions/api/adblock_private.h"
+#include "extensions/browser/browser_context_keyed_api_factory.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_function.h"
+
+class Profile;
+
+namespace extensions {
+
+class AdblockPrivateAPI : public BrowserContextKeyedAPI,
+                          public EventRouter::Observer {
+ public:
+  static BrowserContextKeyedAPIFactory<AdblockPrivateAPI>* GetFactoryInstance();
+
+  static AdblockPrivateAPI* Get(content::BrowserContext* context);
+
+  explicit AdblockPrivateAPI(content::BrowserContext* context);
+  ~AdblockPrivateAPI() override;
+  friend class BrowserContextKeyedAPIFactory<AdblockPrivateAPI>;
+
+  // BrowserContextKeyedAPI implementation.
+  static const char* service_name() { return "AdblockPrivateAPI"; }
+  static const bool kServiceRedirectedInIncognito = true;
+  static const bool kServiceIsCreatedWithBrowserContext = true;
+  void Shutdown() override;
+
+  // EventRouter::Observer:
+  void OnListenerAdded(const extensions::EventListenerInfo& details) override;
+
+ private:
+  raw_ptr<content::BrowserContext> context_;
+  class AdblockAPIEventRouter;
+  std::unique_ptr<AdblockAPIEventRouter> event_router_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    AdblockPrivateAPI>::DeclareFactoryDependencies();
+
+namespace api {
+
+class AdblockPrivateSetEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setEnabled", UNKNOWN)
+  AdblockPrivateSetEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetEnabledFunction(const AdblockPrivateSetEnabledFunction&) =
+      delete;
+  AdblockPrivateSetEnabledFunction& operator=(
+      const AdblockPrivateSetEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isEnabled", UNKNOWN)
+  AdblockPrivateIsEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsEnabledFunction(const AdblockPrivateIsEnabledFunction&) =
+      delete;
+  AdblockPrivateIsEnabledFunction& operator=(
+      const AdblockPrivateIsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateSetAcceptableAdsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setAcceptableAdsEnabled", UNKNOWN)
+  AdblockPrivateSetAcceptableAdsEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetAcceptableAdsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetAcceptableAdsEnabledFunction(
+      const AdblockPrivateSetAcceptableAdsEnabledFunction&) = delete;
+  AdblockPrivateSetAcceptableAdsEnabledFunction& operator=(
+      const AdblockPrivateSetAcceptableAdsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsAcceptableAdsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isAcceptableAdsEnabled", UNKNOWN)
+  AdblockPrivateIsAcceptableAdsEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsAcceptableAdsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsAcceptableAdsEnabledFunction(
+      const AdblockPrivateIsAcceptableAdsEnabledFunction&) = delete;
+  AdblockPrivateIsAcceptableAdsEnabledFunction& operator=(
+      const AdblockPrivateIsAcceptableAdsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateSetAutoInstallEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setAutoInstallEnabled", UNKNOWN)
+  AdblockPrivateSetAutoInstallEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetAutoInstallEnabledFunction(
+      const AdblockPrivateSetAutoInstallEnabledFunction&) = delete;
+  AdblockPrivateSetAutoInstallEnabledFunction& operator=(
+      const AdblockPrivateSetAutoInstallEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsAutoInstallEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isAutoInstallEnabled", UNKNOWN)
+  AdblockPrivateIsAutoInstallEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsAutoInstallEnabledFunction(
+      const AdblockPrivateIsAutoInstallEnabledFunction&) = delete;
+  AdblockPrivateIsAutoInstallEnabledFunction& operator=(
+      const AdblockPrivateIsAutoInstallEnabledFunction&) = delete;
+};
+
+class AdblockPrivateGetBuiltInSubscriptionsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getBuiltInSubscriptions", UNKNOWN)
+  AdblockPrivateGetBuiltInSubscriptionsFunction();
+
+ private:
+  ~AdblockPrivateGetBuiltInSubscriptionsFunction() override;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+
+  AdblockPrivateGetBuiltInSubscriptionsFunction(
+      const AdblockPrivateGetBuiltInSubscriptionsFunction&) = delete;
+  AdblockPrivateGetBuiltInSubscriptionsFunction& operator=(
+      const AdblockPrivateGetBuiltInSubscriptionsFunction&) = delete;
+};
+
+class AdblockPrivateInstallSubscriptionFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.installSubscription", UNKNOWN)
+  AdblockPrivateInstallSubscriptionFunction();
+
+ private:
+  ~AdblockPrivateInstallSubscriptionFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateInstallSubscriptionFunction(
+      const AdblockPrivateInstallSubscriptionFunction&) = delete;
+  AdblockPrivateInstallSubscriptionFunction& operator=(
+      const AdblockPrivateInstallSubscriptionFunction&) = delete;
+};
+
+class AdblockPrivateUninstallSubscriptionFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.uninstallSubscription", UNKNOWN)
+  AdblockPrivateUninstallSubscriptionFunction();
+
+ private:
+  ~AdblockPrivateUninstallSubscriptionFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateUninstallSubscriptionFunction(
+      const AdblockPrivateUninstallSubscriptionFunction&) = delete;
+  AdblockPrivateUninstallSubscriptionFunction& operator=(
+      const AdblockPrivateUninstallSubscriptionFunction&) = delete;
+};
+
+class AdblockPrivateGetInstalledSubscriptionsFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getInstalledSubscriptions",
+                             UNKNOWN)
+  AdblockPrivateGetInstalledSubscriptionsFunction();
+
+ private:
+  ~AdblockPrivateGetInstalledSubscriptionsFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetInstalledSubscriptionsFunction(
+      const AdblockPrivateGetInstalledSubscriptionsFunction&) = delete;
+  AdblockPrivateGetInstalledSubscriptionsFunction& operator=(
+      const AdblockPrivateGetInstalledSubscriptionsFunction&) = delete;
+};
+
+class AdblockPrivateAddAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.addAllowedDomain", UNKNOWN)
+  AdblockPrivateAddAllowedDomainFunction();
+
+ private:
+  ~AdblockPrivateAddAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateAddAllowedDomainFunction(
+      const AdblockPrivateAddAllowedDomainFunction&) = delete;
+  AdblockPrivateAddAllowedDomainFunction& operator=(
+      const AdblockPrivateAddAllowedDomainFunction&) = delete;
+};
+
+class AdblockPrivateRemoveAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.removeAllowedDomain", UNKNOWN)
+  AdblockPrivateRemoveAllowedDomainFunction();
+
+ private:
+  ~AdblockPrivateRemoveAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateRemoveAllowedDomainFunction(
+      const AdblockPrivateRemoveAllowedDomainFunction&) = delete;
+  AdblockPrivateRemoveAllowedDomainFunction& operator=(
+      const AdblockPrivateRemoveAllowedDomainFunction&) = delete;
+};
+
+class AdblockPrivateGetAllowedDomainsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getAllowedDomains", UNKNOWN)
+  AdblockPrivateGetAllowedDomainsFunction();
+
+ private:
+  ~AdblockPrivateGetAllowedDomainsFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetAllowedDomainsFunction(
+      const AdblockPrivateGetAllowedDomainsFunction&) = delete;
+  AdblockPrivateGetAllowedDomainsFunction& operator=(
+      const AdblockPrivateGetAllowedDomainsFunction&) = delete;
+};
+
+class AdblockPrivateAddCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.addCustomFilter", UNKNOWN)
+  AdblockPrivateAddCustomFilterFunction();
+
+ private:
+  ~AdblockPrivateAddCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateAddCustomFilterFunction(
+      const AdblockPrivateAddCustomFilterFunction&) = delete;
+  AdblockPrivateAddCustomFilterFunction& operator=(
+      const AdblockPrivateAddCustomFilterFunction&) = delete;
+};
+
+class AdblockPrivateRemoveCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.removeCustomFilter", UNKNOWN)
+  AdblockPrivateRemoveCustomFilterFunction();
+
+ private:
+  ~AdblockPrivateRemoveCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateRemoveCustomFilterFunction(
+      const AdblockPrivateRemoveCustomFilterFunction&) = delete;
+  AdblockPrivateRemoveCustomFilterFunction& operator=(
+      const AdblockPrivateRemoveCustomFilterFunction&) = delete;
+};
+
+class AdblockPrivateGetCustomFiltersFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getCustomFilters", UNKNOWN)
+  AdblockPrivateGetCustomFiltersFunction();
+
+ private:
+  ~AdblockPrivateGetCustomFiltersFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetCustomFiltersFunction(
+      const AdblockPrivateGetCustomFiltersFunction&) = delete;
+  AdblockPrivateGetCustomFiltersFunction& operator=(
+      const AdblockPrivateGetCustomFiltersFunction&) = delete;
+};
+
+class AdblockPrivateGetSessionAllowedAdsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getSessionAllowedAdsCount",
+                             UNKNOWN)
+  AdblockPrivateGetSessionAllowedAdsCountFunction();
+
+ private:
+  ~AdblockPrivateGetSessionAllowedAdsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetSessionAllowedAdsCountFunction(
+      const AdblockPrivateGetSessionAllowedAdsCountFunction&) = delete;
+  AdblockPrivateGetSessionAllowedAdsCountFunction& operator=(
+      const AdblockPrivateGetSessionAllowedAdsCountFunction&) = delete;
+};
+
+class AdblockPrivateGetSessionBlockedAdsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getSessionBlockedAdsCount",
+                             UNKNOWN)
+  AdblockPrivateGetSessionBlockedAdsCountFunction();
+
+ private:
+  ~AdblockPrivateGetSessionBlockedAdsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetSessionBlockedAdsCountFunction(
+      const AdblockPrivateGetSessionBlockedAdsCountFunction&) = delete;
+  AdblockPrivateGetSessionBlockedAdsCountFunction& operator=(
+      const AdblockPrivateGetSessionBlockedAdsCountFunction&) = delete;
+};
+
+}  // namespace api
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
new file mode 100644
index 0000000000000..f008076fa6467
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
@@ -0,0 +1,174 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <map>
+#include <string>
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+
+namespace extensions {
+
+class AdblockPrivateApiTest
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiTest() {}
+  ~AdblockPrivateApiTest() override = default;
+  AdblockPrivateApiTest(const AdblockPrivateApiTest&) = delete;
+  AdblockPrivateApiTest& operator=(const AdblockPrivateApiTest&) = delete;
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiTestBase::Mode::Incognito;
+  }
+
+  std::string GetApiEndpoint() override {
+    return std::get<0>(GetParam()) ==
+                   AdblockPrivateApiTestBase::EyeoExtensionApi::Old
+               ? "adblockPrivate"
+               : "eyeoFilteringPrivate";
+  }
+
+  std::map<std::string, std::string> FindExpectedDefaultFilterLists() {
+    DCHECK(browser()->profile()->GetOriginalProfile());
+    auto selected = adblock::SubscriptionServiceFactory::GetForBrowserContext(
+                        browser()->profile()->GetOriginalProfile())
+                        ->GetFilteringConfiguration(
+                            adblock::kAdblockFilteringConfigurationName)
+                        ->GetFilterLists();
+    const auto easylist = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(), "easylist.txt");
+        });
+    const auto exceptions = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(),
+                                "exceptionrules.txt");
+        });
+    const auto snippets = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(),
+                                "abp-filters-anti-cv.txt");
+        });
+    if (easylist == selected.end() || exceptions == selected.end() ||
+        snippets == selected.end()) {
+      return std::map<std::string, std::string>{};
+    }
+    return std::map<std::string, std::string>{
+        {"easylist", easylist->spec()},
+        {"exceptions", exceptions->spec()},
+        {"snippets", snippets->spec()}};
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SetAndCheckEnabled) {
+  EXPECT_TRUE(RunTest("setEnabled_isEnabled")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SetAndCheckAAEnabled) {
+  EXPECT_TRUE(RunTest(GetApiEndpoint() == "adblockPrivate"
+                          ? "setAAEnabled_isAAEnabled"
+                          : "setAAEnabled_isAAEnabled_newAPI"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, GetBuiltInSubscriptions) {
+  if (GetApiEndpoint() == "adblockPrivate") {
+    EXPECT_TRUE(RunTest("getBuiltInSubscriptions")) << message_;
+  }
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, InstallSubscriptionInvalidURL) {
+  EXPECT_TRUE(RunTest("installSubscriptionInvalidURL")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, UninstallSubscriptionInvalidURL) {
+  EXPECT_TRUE(RunTest("uninstallSubscriptionInvalidURL")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SubscriptionsManagement) {
+  auto params = FindExpectedDefaultFilterLists();
+  if (params.empty()) {
+    // Since default configuration has been changed let's skip this test
+    return;
+  }
+  EXPECT_TRUE(RunTestWithParams("subscriptionsManagement", params)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest,
+                       SubscriptionsManagementConfigDisabled) {
+  auto params = FindExpectedDefaultFilterLists();
+  if (params.empty()) {
+    // Since default configuration has been changed let's skip this test
+    return;
+  }
+  params.insert({"disabled", "true"});
+  EXPECT_TRUE(RunTestWithParams("subscriptionsManagement", params)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AllowedDomainsManagement) {
+  EXPECT_TRUE(RunTest("allowedDomainsManagement")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, CustomFiltersManagement) {
+  EXPECT_TRUE(RunTest("customFiltersManagement")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AdBlockedEvents) {
+  EXPECT_TRUE(RunTest("adBlockedEvents")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AdAllowedEvents) {
+  EXPECT_TRUE(RunTest("adAllowedEvents")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SessionStats) {
+  EXPECT_TRUE(RunTest("sessionStats")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AllowedDomainsEvent) {
+  EXPECT_TRUE(RunTest("allowedDomainsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, EnabledStateEvent) {
+  EXPECT_TRUE(RunTest("enabledStateEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, FilterListsEvent) {
+  EXPECT_TRUE(RunTest("filterListsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, CustomFiltersEvent) {
+  EXPECT_TRUE(RunTest("customFiltersEvent")) << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ,
+    AdblockPrivateApiTest,
+    testing::Combine(
+        testing::Values(AdblockPrivateApiTestBase::EyeoExtensionApi::Old,
+                        AdblockPrivateApiTestBase::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiTestBase::Mode::Normal,
+                        AdblockPrivateApiTestBase::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
new file mode 100644
index 0000000000000..e284ab411414b
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
@@ -0,0 +1,398 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/content_mock_cert_verifier.h"
+#include "extensions/browser/background_script_executor.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace extensions {
+
+// Here are extension API tests for PageAllowed event and popup
+// events and stats, which are difficult to implement like other
+// tests in AdblockPrivateAPI class (purely in JS in test.js file).
+// Tests here require a background page to run script code.
+class AdblockPrivateApiBackgroundPageTest
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiBackgroundPageTest() {}
+  ~AdblockPrivateApiBackgroundPageTest() override = default;
+  AdblockPrivateApiBackgroundPageTest(
+      const AdblockPrivateApiBackgroundPageTest&) = delete;
+  AdblockPrivateApiBackgroundPageTest& operator=(
+      const AdblockPrivateApiBackgroundPageTest&) = delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    AdblockPrivateApiTestBase::SetUpCommandLine(command_line);
+    mock_cert_verifier_.SetUpCommandLine(command_line);
+  }
+
+ protected:
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+
+    // Map example.com to localhost.
+    host_resolver()->AddRule("example.com", "127.0.0.1");
+
+    mock_cert_verifier_.mock_cert_verifier()->set_default_result(net::OK);
+
+    https_test_server_ = std::make_unique<net::EmbeddedTestServer>(
+        net::EmbeddedTestServer::TYPE_HTTPS);
+    https_test_server_->SetSSLConfig(net::EmbeddedTestServer::CERT_OK);
+    https_test_server_->ServeFilesFromSourceDirectory(GetChromeTestDataDir());
+    ASSERT_TRUE(https_test_server_->Start());
+
+    ASSERT_TRUE(StartEmbeddedTestServer());
+    adblock::SubscriptionServiceFactory::GetForBrowserContext(
+        browser()->profile()->GetOriginalProfile())
+        ->GetFilteringConfiguration(adblock::kAdblockFilteringConfigurationName)
+        ->RemoveCustomFilter(adblock::kAllowlistEverythingFilter);
+
+    extension_ = LoadExtension(test_data_dir_.AppendASCII("adblock_private"),
+                               {.allow_in_incognito = IsIncognito()});
+    ASSERT_TRUE(extension_);
+  }
+
+  bool IsOldApi() { return std::get<0>(GetParam()) == EyeoExtensionApi::Old; }
+
+  std::string GetApiEndpoint() override {
+    return IsOldApi() ? "adblockPrivate" : "eyeoFilteringPrivate";
+  }
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiBackgroundPageTest::Mode::Incognito;
+  }
+
+  void ExecuteScript(const std::string& js_code) const {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetWebContentsAt(0);
+    ASSERT_TRUE(content::ExecJs(web_contents->GetPrimaryMainFrame(), js_code));
+  }
+
+  int ExecuteScriptAndGetInt(const std::string& extension_id,
+                             const std::string& script) {
+    return ExtensionApiTest::ExecuteScriptInBackgroundPage(extension_id, script)
+        .GetInt();
+  }
+
+  void SetupApiObjectAndMethods(const std::string& extension_id) {
+    std::string setup_script;
+    if (IsOldApi()) {
+      setup_script =
+          "let apiObject = chrome.adblockPrivate;"
+          "let sessionAllowedCount = 'getSessionAllowedAdsCount';"
+          "let sessionBlockedCount = 'getSessionBlockedAdsCount';"
+          "let onAllowedEvent = 'onAdAllowed';"
+          "let onBlockedEvent = 'onAdBlocked';"
+          "chrome.test.sendScriptResult(0);";
+    } else {
+      setup_script =
+          "let apiObject = chrome.eyeoFilteringPrivate;"
+          "let sessionAllowedCount = 'getSessionAllowedRequestsCount';"
+          "let sessionBlockedCount = 'getSessionBlockedRequestsCount';"
+          "let onAllowedEvent = 'onRequestAllowed';"
+          "let onBlockedEvent = 'onRequestBlocked';"
+          "chrome.test.sendScriptResult(0);";
+    }
+    ExecuteScriptAndGetInt(extension_id, setup_script);
+  }
+
+  const ExtensionId& GetExtensionId() const { return extension_->id(); }
+
+  std::unique_ptr<net::EmbeddedTestServer> https_test_server_;
+  content::ContentMockCertVerifier mock_cert_verifier_;
+  raw_ptr<const Extension, DanglingUntriaged> extension_;
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PageAllowedEvents) {
+  constexpr char kSetListenersScript[] = R"(
+    let testData = {};
+    testData.pageAllowedCount = 0;
+    apiObject.onPageAllowed.addListener(function(e) {
+      if (!e.url.endsWith('test.html')) {
+        return;
+      }
+      testData.pageAllowedCount = testData.pageAllowedCount + 1;
+    });
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kReadCountersScript[] = R"(
+    var intervalId = setInterval(function() {
+      if (testData.pageAllowedCount == %d) {
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+        chrome.test.sendScriptResult(testData.pageAllowedCount);
+      }
+    }, 100);
+  )";
+
+  constexpr char kAllowDomainScript[] = R"(
+    apiObject.addAllowedDomain(%s'example.com');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  ExecuteScriptAndGetInt(GetExtensionId(), kSetListenersScript);
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  ASSERT_EQ(0,
+            ExecuteScriptAndGetInt(GetExtensionId(),
+                                   base::StringPrintf(kReadCountersScript, 0)));
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowDomainScript, IsOldApi() ? "" : "'adblock', "));
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  ASSERT_EQ(1,
+            ExecuteScriptAndGetInt(GetExtensionId(),
+                                   base::StringPrintf(kReadCountersScript, 1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PageAllowedStats) {
+  constexpr char kReadAllowedStatsScript[] = R"(
+    var intervalId = setInterval(function() {
+      apiObject[sessionAllowedCount](function(sessionStats) {
+        let count = 0;
+        for (const entry of sessionStats) {
+          if (entry.url === 'adblock:custom') {
+            count = entry.count;
+          }
+        }
+        if (%d == 0 || count == %d) {
+          if (intervalId) {
+            clearInterval(intervalId);
+            intervalId = null;
+          }
+          chrome.test.sendScriptResult(count);
+        }
+      });
+    }, 100);
+  )";
+
+  constexpr char kAllowDomainScript[] = R"(
+    apiObject.addAllowedDomain(%s'example.com');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  int initial_value = ExecuteScriptAndGetInt(
+      GetExtensionId(), base::StringPrintf(kReadAllowedStatsScript, 0, 0));
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowDomainScript, IsOldApi() ? "" : "'adblock', "));
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+
+  EXPECT_EQ(
+      initial_value + 1,
+      ExecuteScriptAndGetInt(
+          GetExtensionId(), base::StringPrintf(kReadAllowedStatsScript, 1, 1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PopupEvents) {
+  constexpr char kSetListenersScript[] = R"(
+    let testData = {};
+    testData.popupBlockedCount = 0;
+    testData.popupAllowedCount = 0;
+    apiObject.onPopupAllowed.addListener(function(e, blocked) {
+      if (!e.url.endsWith('some-popup.html')) {
+        return;
+      }
+      testData.popupAllowedCount = testData.popupAllowedCount + 1;
+    });
+    apiObject.onPopupBlocked.addListener(function(e, blocked) {
+      if (!e.url.endsWith('some-popup.html')) {
+        return;
+      }
+      testData.popupBlockedCount = testData.popupBlockedCount + 1;
+    });
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char verify_stats_script_tmpl[] = R"(
+        var intervalId = setInterval(function() {
+          let result = testData.%s;
+          if (result == %d) {
+            if (intervalId) {
+              clearInterval(intervalId);
+              intervalId = null;
+            }
+            chrome.test.sendScriptResult(result);
+          }
+        }, 100);
+  )";
+
+  auto read_allowed_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(verify_stats_script_tmpl,
+                                            "popupAllowedCount", expected);
+    return script;
+  };
+
+  auto read_blocked_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(verify_stats_script_tmpl,
+                                            "popupBlockedCount", expected);
+    return script;
+  };
+
+  constexpr char kBlockPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kAllowPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'@@some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+  constexpr char kOpenPopupScript[] =
+      "document.getElementById('popup_id').click()";
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  ExecuteScriptAndGetInt(GetExtensionId(), kSetListenersScript);
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kBlockPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  EXPECT_EQ(0, ExecuteScriptAndGetInt(GetExtensionId(),
+                                      read_allowed_stats_script(0)));
+  EXPECT_EQ(1, ExecuteScriptAndGetInt(GetExtensionId(),
+                                      read_blocked_stats_script(1)));
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  EXPECT_EQ(1, ExecuteScriptAndGetInt(GetExtensionId(),
+                                      read_allowed_stats_script(1)));
+  EXPECT_EQ(1, ExecuteScriptAndGetInt(GetExtensionId(),
+                                      read_blocked_stats_script(1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PopupStats) {
+  constexpr char verify_stats_script_tmpl[] = R"(
+    var intervalId = setInterval(function() {
+      apiObject[%s](function(sessionStats) {
+        let count = 0;
+        for (const entry of sessionStats) {
+          if (entry.url === 'adblock:custom') {
+            count = entry.count;
+          }
+        }
+        if (%d == 0 || count == %d) {
+          if (intervalId) {
+            clearInterval(intervalId);
+            intervalId = null;
+          }
+          chrome.test.sendScriptResult(count);
+        }
+      }
+    )}, 100);
+  )";
+
+  auto read_allowed_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(
+        verify_stats_script_tmpl, "sessionAllowedCount", expected, expected);
+    return script;
+  };
+
+  auto read_blocked_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(
+        verify_stats_script_tmpl, "sessionBlockedCount", expected, expected);
+    return script;
+  };
+
+  constexpr char kBlockPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kAllowPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'@@some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+  constexpr char kOpenPopupScript[] =
+      "document.getElementById('popup_id').click()";
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  int initial_allowed_value =
+      ExecuteScriptAndGetInt(GetExtensionId(), read_allowed_stats_script(0));
+  int initial_blocked_value =
+      ExecuteScriptAndGetInt(GetExtensionId(), read_blocked_stats_script(0));
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kBlockPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  ASSERT_EQ(initial_blocked_value + 1,
+            ExecuteScriptAndGetInt(
+                GetExtensionId(),
+                read_blocked_stats_script(initial_blocked_value + 1)));
+
+  ExecuteScriptAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  ASSERT_EQ(initial_allowed_value + 1,
+            ExecuteScriptAndGetInt(
+                GetExtensionId(),
+                read_allowed_stats_script(initial_allowed_value + 1)));
+  ASSERT_EQ(initial_blocked_value + 1,
+            ExecuteScriptAndGetInt(
+                GetExtensionId(),
+                read_blocked_stats_script(initial_blocked_value + 1)));
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    All,
+    AdblockPrivateApiBackgroundPageTest,
+    testing::Combine(
+        testing::Values(
+            AdblockPrivateApiBackgroundPageTest::EyeoExtensionApi::Old,
+            AdblockPrivateApiBackgroundPageTest::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiBackgroundPageTest::Mode::Normal,
+                        AdblockPrivateApiBackgroundPageTest::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
new file mode 100644
index 0000000000000..dc0d4b32ed984
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
@@ -0,0 +1,103 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/extensions/api/adblock_private.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/adblock_request_throttle_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/net/adblock_request_throttle.h"
+#include "extensions/common/switches.h"
+
+namespace extensions {
+
+void AdblockPrivateApiTestBase::SetUpCommandLine(
+    base::CommandLine* command_line) {
+  ExtensionApiTest::SetUpCommandLine(command_line);
+  AllowTestExtension(command_line);
+  if (IsIncognito()) {
+    EnableIncognitoMode(command_line);
+  }
+}
+
+void AdblockPrivateApiTestBase::SetUpOnMainThread() {
+  ExtensionApiTest::SetUpOnMainThread();
+
+  // When any of that fails we need to update comment in adblock_private.idl
+  ASSERT_EQ(api::tabs::TAB_ID_NONE, -1);
+  ASSERT_EQ(SessionID::InvalidValue().id(), -1);
+
+  adblock::SubscriptionServiceFactory::GetForBrowserContext(
+      browser()->profile()->GetOriginalProfile())
+      ->GetFilteringConfiguration(adblock::kAdblockFilteringConfigurationName)
+      ->RemoveCustomFilter(adblock::kAllowlistEverythingFilter);
+  // Allow requests for filter lists to be "downloaded" immediately, otherwise
+  // the tests will hang for 30 seconds.
+  adblock::AdblockRequestThrottleFactory::GetForBrowserContext(
+      browser()->profile()->GetOriginalProfile())
+      ->AllowRequestsAfter(base::Seconds(0));
+
+  AdblockChromeContentBrowserClient::ForceAdblockProxyForTesting();
+}
+
+bool AdblockPrivateApiTestBase::IsIncognito() {
+  return false;
+}
+
+std::string AdblockPrivateApiTestBase::GetApiEndpoint() {
+  return "adblockPrivate";
+}
+
+bool AdblockPrivateApiTestBase::RunTest(const std::string& subtest) {
+  std::string page_url = "main.html?subtest=" + subtest;
+  page_url += "&api=" + GetApiEndpoint();
+  return RunExtensionTest("adblock_private",
+                          {.extension_url = page_url.c_str()},
+                          {.allow_in_incognito = IsIncognito(),
+                           .load_as_component = !IsIncognito()});
+}
+
+bool AdblockPrivateApiTestBase::RunTestWithParams(
+    const std::string& subtest,
+    const std::map<std::string, std::string>& params) {
+  if (params.empty()) {
+    return RunTest(subtest);
+  }
+  std::string subtest_with_params = subtest;
+  for (const auto& [key, value] : params) {
+    subtest_with_params += "&" + key + "=" + value;
+  }
+  return RunTest(subtest_with_params);
+}
+
+void AdblockPrivateApiTestBase::AllowTestExtension(
+    base::CommandLine* command_line) {
+  command_line->AppendSwitchASCII(switches::kAllowlistedExtensionID,
+                                  "hfkjbmnbjpodjjpikbpnphphoimfacom");
+}
+
+void AdblockPrivateApiTestBase::EnableIncognitoMode(
+    base::CommandLine* command_line) {
+  command_line->AppendSwitch(::switches::kIncognito);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
new file mode 100644
index 0000000000000..b421587d531b0
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
@@ -0,0 +1,62 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
+
+#include <map>
+#include <string>
+
+#include "base/command_line.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "content/public/test/browser_test.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace extensions {
+
+class AdblockPrivateApiTestBase : public ExtensionApiTest {
+ public:
+  enum class Mode { Normal, Incognito };
+  enum class EyeoExtensionApi { Old, New };
+
+  AdblockPrivateApiTestBase() {}
+  ~AdblockPrivateApiTestBase() override = default;
+  AdblockPrivateApiTestBase(const AdblockPrivateApiTestBase&) = delete;
+  AdblockPrivateApiTestBase& operator=(const AdblockPrivateApiTestBase&) =
+      delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override;
+  void SetUpOnMainThread() override;
+
+  virtual bool IsIncognito();
+
+  virtual std::string GetApiEndpoint();
+
+  virtual bool RunTest(const std::string& subtest);
+
+  virtual bool RunTestWithParams(
+      const std::string& subtest,
+      const std::map<std::string, std::string>& params);
+
+ private:
+  void AllowTestExtension(base::CommandLine* command_line);
+
+  void EnableIncognitoMode(base::CommandLine* command_line);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
new file mode 100644
index 0000000000000..8b5e187707639
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
@@ -0,0 +1,188 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <memory>
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "net/test/embedded_test_server/http_request.h"
+#include "net/test/embedded_test_server/http_response.h"
+
+namespace extensions {
+
+/**
+ * Extension tests which require intercepting and returning content
+ * for filter lists download requests.
+ */
+class AdblockPrivateApiFilterListWithHttpServer
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiFilterListWithHttpServer()
+      : https_server_(net::EmbeddedTestServer::TYPE_HTTPS) {
+    const auto testing_interval = base::Seconds(1);
+    adblock::SubscriptionServiceFactory::SetUpdateCheckIntervalForTesting(
+        testing_interval);
+    https_server_.RegisterRequestHandler(base::BindRepeating(
+        &AdblockPrivateApiFilterListWithHttpServer::RequestHandler,
+        base::Unretained(this)));
+    net::EmbeddedTestServer::ServerCertificateConfig cert_config;
+    cert_config.dns_names = {kEyeoFilterListHost};
+    https_server_.SetSSLConfig(cert_config);
+    EXPECT_TRUE(https_server_.Start());
+    adblock::SetFilterListServerPortForTesting(https_server_.port());
+    geolocated_list_1_ =
+        base::StringPrintf("https://%s:%d/easylistpolish.txt",
+                           kEyeoFilterListHost, https_server_.port());
+    geolocated_list_2_ =
+        base::StringPrintf("https://%s:%d/easylistgermany.txt",
+                           kEyeoFilterListHost, https_server_.port());
+  }
+
+  ~AdblockPrivateApiFilterListWithHttpServer() override = default;
+  AdblockPrivateApiFilterListWithHttpServer(
+      const AdblockPrivateApiFilterListWithHttpServer&) = delete;
+  AdblockPrivateApiFilterListWithHttpServer& operator=(
+      const AdblockPrivateApiFilterListWithHttpServer&) = delete;
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiTestBase::Mode::Incognito;
+  }
+
+  std::string GetApiEndpoint() override {
+    return std::get<0>(GetParam()) ==
+                   AdblockPrivateApiTestBase::EyeoExtensionApi::Old
+               ? "adblockPrivate"
+               : "eyeoFilteringPrivate";
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (base::StartsWith(request.relative_url, "/recommendations.json")) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      auto payload = base::StringPrintf(
+          R"(
+          [{"url": "%s"}, {"url": "%s"}]
+        )",
+          geolocated_list_1_.c_str(), geolocated_list_2_.c_str());
+      http_response->set_content(payload);
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    } else if (base::StartsWith(request.relative_url, "/easylistpolish.txt") ||
+               base::StartsWith(request.relative_url, "/easylistgermany.txt") ||
+               base::StartsWith(request.relative_url, "/easylist.txt") ||
+               base::StartsWith(request.relative_url, "/exceptionrules.txt") ||
+               base::StartsWith(request.relative_url,
+                                "/abp-filters-anti-cv.txt")) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      auto filename = request.GetURL().path();
+      auto filter_list_header =
+          base::StringPrintf("[Adblock Plus 2.0]\n! Version: %zu\n! Title: %s",
+                             filename.length(), filename.c_str());
+      http_response->set_content(filter_list_header);
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404.
+    // This is fine for the purpose of this test.
+    return nullptr;
+  }
+
+  void SetUpOnMainThread() override {
+    AdblockPrivateApiTestBase::SetUpOnMainThread();
+    host_resolver()->AddRule(kEyeoFilterListHost, "127.0.0.1");
+  }
+
+  void WaitForGeolocatedLists() {
+    std::vector<GURL> subscriptions = {GURL(geolocated_list_1_),
+                                       GURL(geolocated_list_2_)};
+    WaitForLists(subscriptions);
+  }
+
+  void WaitForDefaultLists() {
+    std::vector<GURL> subscriptions = {
+        GURL(base::StringPrintf("https://%s:%d/easylist.txt",
+                                kEyeoFilterListHost, https_server_.port())),
+        GURL(base::StringPrintf("https://%s:%d/exceptionrules.txt",
+                                kEyeoFilterListHost, https_server_.port())),
+        GURL(base::StringPrintf("https://%s:%d/abp-filters-anti-cv.txt",
+                                kEyeoFilterListHost, https_server_.port()))};
+    WaitForLists(subscriptions);
+  }
+
+ protected:
+  net::EmbeddedTestServer https_server_;
+  std::string geolocated_list_1_;
+  std::string geolocated_list_2_;
+
+ private:
+  void WaitForLists(const std::vector<GURL>& subscriptions) {
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile());
+    auto waiter = adblock::SubscriptionInstalledWaiter(subscription_service);
+    waiter.WaitUntilSubscriptionsInstalled(std::move(subscriptions));
+  }
+  static constexpr char kEyeoFilterListHost[] =
+      "easylist-downloads.adblockplus.org";
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       InstalledSubscriptionsDataSchema) {
+  WaitForDefaultLists();
+  EXPECT_TRUE(RunTest("installedSubscriptionsDataSchema")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       InstalledSubscriptionsDataSchemaConfigDisabled) {
+  EXPECT_TRUE(RunTestWithParams("installedSubscriptionsDataSchema",
+                                {{"disabled", "true"}}))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       GeolocationDiabledHidesFilterLists) {
+  WaitForGeolocatedLists();
+  EXPECT_TRUE(RunTestWithParams("disableGeolocation",
+                                {{"geolocated_list_1", geolocated_list_1_},
+                                 {"geolocated_list_2", geolocated_list_2_}}))
+      << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ,
+    AdblockPrivateApiFilterListWithHttpServer,
+    testing::Combine(
+        testing::Values(AdblockPrivateApiTestBase::EyeoExtensionApi::Old,
+                        AdblockPrivateApiTestBase::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiTestBase::Mode::Normal,
+                        AdblockPrivateApiTestBase::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc b/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
index 139f834052964..5dfc25929946c 100644
--- a/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
+++ b/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
@@ -19,10 +19,13 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/extensions/api/activity_log_private/activity_log_private_api.h"
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_api.h"
 #include "chrome/browser/extensions/api/autofill_private/autofill_private_event_router_factory.h"
 #include "chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.h"
 #include "chrome/browser/extensions/api/braille_display_private/braille_display_private_api.h"
 #include "chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_event_router.h"
+#include "chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h"
+#include "chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h"
 #include "chrome/browser/extensions/api/font_settings/font_settings_api.h"
 #include "chrome/browser/extensions/api/identity/identity_api.h"
 #include "chrome/browser/extensions/api/image_writer_private/operation_manager.h"
@@ -88,6 +91,7 @@ void EnsureApiBrowserContextKeyedServiceFactoriesBuilt() {
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::ActivityLogAPI::GetFactoryInstance();
+  extensions::AdblockPrivateAPI::GetFactoryInstance();
   extensions::AutofillPrivateEventRouterFactory::GetInstance();
   extensions::BluetoothLowEnergyAPI::GetFactoryInstance();
   extensions::BookmarkManagerPrivateAPI::GetFactoryInstance();
@@ -96,6 +100,8 @@ void EnsureApiBrowserContextKeyedServiceFactoriesBuilt() {
   extensions::DocumentScanAPIHandler::GetFactoryInstance();
 #endif
   extensions::EnterpriseReportingPrivateEventRouterFactory::GetInstance();
+  extensions::EyeoDevToolsPrivateAPI::GetFactoryInstance();
+  extensions::EyeoFilteringPrivateAPI::GetFactoryInstance();
   extensions::FontSettingsAPI::GetFactoryInstance();
   extensions::IdentityAPI::GetFactoryInstance();
   extensions::IncognitoConnectability::EnsureFactoryBuilt();
diff --git a/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.cc b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.cc
new file mode 100644
index 0000000000000..839aeb5012566
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.cc
@@ -0,0 +1,447 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h"
+
+#include <map>
+
+#include "base/json/json_reader.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/strings/string_split.h"
+#include "base/strings/stringprintf.h"
+#include "base/values.h"
+#include "chrome/browser/devtools/device/devtools_android_bridge.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/prefs/pref_service.h"
+#include "url/gurl.h"
+
+namespace extensions {
+
+namespace {
+
+constexpr char kOtherTargetAlreadyConnected[] =
+    "There is already another remote target '%s' connected or connecting!";
+
+constexpr char kTargetMissing[] = "Target '%s' is not reachable!";
+
+constexpr char kTargetAlreadyConnected[] = "Connect already called for '%s'!";
+
+content::BrowserContext* GetOriginalBrowserContext(
+    content::BrowserContext* browser_context) {
+  return Profile::FromBrowserContext(browser_context)->GetOriginalProfile();
+}
+
+DevToolsAndroidBridge* GetDevToolsAndroidBridge(
+    content::BrowserContext* browser_context) {
+  return DevToolsAndroidBridge::Factory::GetForProfile(
+      Profile::FromBrowserContext(browser_context)->GetOriginalProfile());
+}
+
+AndroidDeviceManager::AndroidWebSocket*& SocketPtr(
+    EyeoDevToolsPrivateAPI::Socket& socket) {
+  return std::get<0>(socket);
+}
+
+std::string& SocketName(EyeoDevToolsPrivateAPI::Socket& socket) {
+  return std::get<1>(socket);
+}
+
+std::optional<base::OnceCallback<void()>>& SocketReadyCallback(
+    EyeoDevToolsPrivateAPI::Socket& socket) {
+  return std::get<2>(socket);
+}
+
+extensions::api::eyeo_dev_tools_private::RequestInfo CreateRequestInfoObject(
+    const std::string& url,
+    const std::string& subscription) {
+  api::eyeo_dev_tools_private::RequestInfo info;
+  info.url = url;
+  info.subscription = subscription;
+  return info;
+}
+
+extensions::api::eyeo_dev_tools_private::PageElementInfo
+CreatePageElementInfoObject(const std::string& selector,
+                            const std::string& action) {
+  api::eyeo_dev_tools_private::PageElementInfo info;
+  info.selector = selector;
+  info.action = action;
+  return info;
+}
+
+}  // namespace
+
+class EyeoDevToolsPrivateAPI::EyeoDevToolsAPIEventRouter
+    : public DevToolsAndroidBridge::DeviceListListener {
+ public:
+  explicit EyeoDevToolsAPIEventRouter(content::BrowserContext* context)
+      : context_(GetOriginalBrowserContext(context)) {
+    auto* bridge = GetDevToolsAndroidBridge(context_);
+    CHECK(bridge);
+    bridge->AddDeviceListListener(this);
+  }
+
+  ~EyeoDevToolsAPIEventRouter() override {
+    auto* bridge = GetDevToolsAndroidBridge(context_);
+    CHECK(bridge);
+    bridge->RemoveDeviceListListener(this);
+  }
+
+  void DeviceListChanged(
+      const DevToolsAndroidBridge::RemoteDevices& devices) override {
+    std::map<std::string, scoped_refptr<AndroidDeviceManager::Device>>
+        current_targets;
+    auto& last_targets =
+        EyeoDevToolsPrivateAPI::Get(context_)->GetRemoteTargets();
+    for (const auto& device : devices) {
+      if (device->is_connected()) {
+        for (const auto& browser : device->browsers()) {
+          for (const auto& page : browser->pages()) {
+            auto dt_agent_host = page->CreateTarget();
+            if (dt_agent_host->GetType() != "page") {
+              continue;
+            }
+            auto socket_target = dt_agent_host->GetId();
+            current_targets[socket_target] = page->device();
+            if (last_targets.erase(socket_target) > 0) {
+              // This isn't a new remote target
+              continue;
+            }
+            VLOG(2) << "[eyeo] Found a new remote target:";
+            VLOG(2) << "\t\t[eyeo] page url: " << dt_agent_host->GetURL();
+            VLOG(2) << "\t\t[eyeo] page socket: " << socket_target;
+            api::eyeo_dev_tools_private::RemoteTargetInfo info =
+                CreateRemoteTargetInfoObject(dt_agent_host->GetURL(),
+                                             socket_target);
+            std::unique_ptr<Event> event = std::make_unique<Event>(
+                events::EYEO_EVENT,
+                api::eyeo_dev_tools_private::OnRemoteTargetFound::kEventName,
+                api::eyeo_dev_tools_private::OnRemoteTargetFound::Create(info));
+
+            extensions::EventRouter::Get(context_)->BroadcastEvent(
+                std::move(event));
+          }
+        }
+      }
+    }
+    for (const auto& target : last_targets) {
+      VLOG(2) << "[eyeo] Lost a remote target:";
+      VLOG(2) << "\t\t[eyeo] page socket: " << target.first;
+      api::eyeo_dev_tools_private::RemoteTargetInfo info =
+          CreateRemoteTargetInfoObject(GURL{}, target.first);
+      std::unique_ptr<Event> event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_dev_tools_private::OnRemoteTargetLost::kEventName,
+          api::eyeo_dev_tools_private::OnRemoteTargetLost::Create(info));
+
+      extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+    }
+    last_targets.swap(current_targets);
+  }
+
+ private:
+  api::eyeo_dev_tools_private::RemoteTargetInfo CreateRemoteTargetInfoObject(
+      const GURL& page_url,
+      const std::string& socket_name) {
+    api::eyeo_dev_tools_private::RemoteTargetInfo info;
+    info.page_url = page_url.spec();
+    info.socket_name = socket_name;
+    return info;
+  }
+
+  const raw_ptr<content::BrowserContext> context_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoDevToolsPrivateAPI>::DeclareFactoryDependencies() {
+  DependsOn(DevToolsAndroidBridge::Factory::GetInstance());
+}
+
+// static
+BrowserContextKeyedAPIFactory<EyeoDevToolsPrivateAPI>*
+EyeoDevToolsPrivateAPI::GetFactoryInstance() {
+  static base::NoDestructor<
+      BrowserContextKeyedAPIFactory<EyeoDevToolsPrivateAPI>>
+      instance;
+  return instance.get();
+}
+
+// static
+EyeoDevToolsPrivateAPI* EyeoDevToolsPrivateAPI::Get(
+    content::BrowserContext* context) {
+  return GetFactoryInstance()->Get(context);
+}
+
+EyeoDevToolsPrivateAPI::EyeoDevToolsPrivateAPI(content::BrowserContext* context)
+    : context_(context) {
+  // EventRouter can be null in tests
+  auto* ev = EventRouter::Get(context_);
+  if (ev) {
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnPageAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnRemoteTargetFound::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnRemoteTargetLost::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnRequestAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnRequestBlocked::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_dev_tools_private::OnPageElementMatched::kEventName);
+  }
+  socket_ = std::make_tuple(nullptr, "", std::nullopt);
+}
+
+EyeoDevToolsPrivateAPI::~EyeoDevToolsPrivateAPI() {
+  if (SocketPtr(socket_)) {
+    delete SocketPtr(socket_);
+    SocketPtr(socket_) = nullptr;
+  }
+}
+
+void EyeoDevToolsPrivateAPI::Shutdown() {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->UnregisterObserver(this);
+  }
+  event_router_.reset();
+}
+
+void EyeoDevToolsPrivateAPI::OnListenerAdded(
+    const extensions::EventListenerInfo& details) {
+  event_router_ =
+      std::make_unique<EyeoDevToolsPrivateAPI::EyeoDevToolsAPIEventRouter>(
+          context_);
+  EventRouter::Get(context_)->UnregisterObserver(this);
+}
+
+void EyeoDevToolsPrivateAPI::SendMessage(
+    const std::string& command,
+    const std::string& params,
+    base::OnceCallback<void(const std::string&)> callback) {
+  static int s_message_id = 0;
+  static constexpr char s_message_tmpl[] =
+      "{\"id\":%d,\"method\":\"Eyeo.%s\",\"params\":%s}";
+  DCHECK(SocketPtr(socket_));
+  auto next_massage_id = s_message_id++;
+  messages_[next_massage_id] = std::move(callback);
+  auto message = base::StringPrintf(s_message_tmpl, next_massage_id, command,
+                                    params.empty() ? "{}" : params);
+  SocketPtr(socket_)->SendFrame(message);
+}
+
+void EyeoDevToolsPrivateAPI::OnSocketOpened() {
+  VLOG(2) << "[eyeo] EyeoDevToolsPrivateAPI::OnSocketOpened: "
+          << SocketName(socket_);
+  DCHECK(SocketReadyCallback(socket_).has_value());
+  if (SocketReadyCallback(socket_).has_value()) {
+    std::move(SocketReadyCallback(socket_).value()).Run();
+    SocketReadyCallback(socket_) = std::nullopt;
+  }
+}
+
+void EyeoDevToolsPrivateAPI::OnFrameRead(const std::string& message) {
+  VLOG(2) << "[eyeo] EyeoDevToolsPrivateAPI::OnFrameRead: " << message;
+  std::optional<base::Value::Dict> json = base::JSONReader::ReadDict(message);
+  if (json) {
+    if (json->FindInt("id")) {
+      auto key = json->FindInt("id").value();
+      auto cb_entry = messages_.find(key);
+      DCHECK(cb_entry != messages_.end());
+      if (cb_entry != messages_.end()) {
+        std::move(messages_[key]).Run(message);
+        messages_.erase(cb_entry);
+      }
+    } else if (json->FindString("method") && json->FindDict("params")) {
+      auto action = *json->FindString("method");
+      if (action == "Eyeo.pageAllowed" || action == "Eyeo.requestAllowed" ||
+          action == "Eyeo.requestBlocked") {
+        auto* params = json->FindDict("params");
+        auto url = (params->FindString("url") ? *params->FindString("url")
+                                              : std::string("<?>"));
+        auto subscription = (params->FindString("subscription")
+                                 ? *params->FindString("subscription")
+                                 : std::string("<?>"));
+        api::eyeo_dev_tools_private::RequestInfo info =
+            CreateRequestInfoObject(url, subscription);
+        std::unique_ptr<Event> event;
+        if (action == "Eyeo.requestAllowed") {
+          event = std::make_unique<Event>(
+              events::EYEO_EVENT,
+              api::eyeo_dev_tools_private::OnRequestAllowed::kEventName,
+              api::eyeo_dev_tools_private::OnRequestAllowed::Create(info));
+        } else if (action == "Eyeo.requestBlocked") {
+          event = std::make_unique<Event>(
+              events::EYEO_EVENT,
+              api::eyeo_dev_tools_private::OnRequestBlocked::kEventName,
+              api::eyeo_dev_tools_private::OnRequestBlocked::Create(info));
+        } else {
+          event = std::make_unique<Event>(
+              events::EYEO_EVENT,
+              api::eyeo_dev_tools_private::OnPageAllowed::kEventName,
+              api::eyeo_dev_tools_private::OnPageAllowed::Create(info));
+        }
+        extensions::EventRouter::Get(context_)->BroadcastEvent(
+            std::move(event));
+      } else if (action == "Eyeo.pageElementMatched") {
+        auto* params = json->FindDict("params");
+        auto selector =
+            (params->FindString("selector") ? *params->FindString("selector")
+                                            : std::string("<?>"));
+        auto eh_action =
+            (params->FindString("action") ? *params->FindString("action")
+                                          : std::string("<?>"));
+        api::eyeo_dev_tools_private::PageElementInfo info =
+            CreatePageElementInfoObject(selector, eh_action);
+        std::unique_ptr<Event> event = std::make_unique<Event>(
+            events::EYEO_EVENT,
+            api::eyeo_dev_tools_private::OnPageElementMatched::kEventName,
+            api::eyeo_dev_tools_private::OnPageElementMatched::Create(info));
+        extensions::EventRouter::Get(context_)->BroadcastEvent(
+            std::move(event));
+      }
+    }
+  }
+}
+
+void EyeoDevToolsPrivateAPI::OnSocketClosed() {
+  VLOG(2) << "[eyeo] EyeoDevToolsPrivateAPI::OnSocketClosed: "
+          << SocketName(socket_);
+  delete SocketPtr(socket_);
+  SocketPtr(socket_) = nullptr;
+}
+
+namespace api {
+
+ExtensionFunction::ResponseAction EyeoDevToolsPrivateConnectFunction::Run() {
+  std::optional<eyeo_dev_tools_private::Connect::Params> params(
+      eyeo_dev_tools_private::Connect::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto socket_name = params->socket_name;
+  auto* extension = EyeoDevToolsPrivateAPI::Get(browser_context());
+  auto& socket = extension->GetSocket();
+  // Check if we are already connected or connecting
+  if (SocketPtr(socket)) {
+    if (SocketName(socket) == socket_name) {
+      return RespondNow(Error(
+          base::StringPrintf(kTargetAlreadyConnected, socket_name.c_str())));
+    } else {
+      return RespondNow(Error(base::StringPrintf(kOtherTargetAlreadyConnected,
+                                                 socket_name.c_str())));
+    }
+  }
+  auto& remote_targets = extension->GetRemoteTargets();
+  if (!remote_targets.count(socket_name)) {
+    return RespondNow(
+        Error(base::StringPrintf(kTargetMissing, socket_name.c_str())));
+  }
+
+  SocketReadyCallback(socket) = base::BindOnce(
+      &EyeoDevToolsPrivateConnectFunction::RespondSocketConnected, this);
+
+  SocketName(socket) = socket_name;
+  std::vector<std::string> socket_tokens = base::SplitString(
+      socket_name, ":", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+  SocketPtr(socket) = remote_targets[socket_name]->CreateWebSocket(
+      socket_tokens[1], "/devtools/page/" + socket_tokens[2], extension);
+
+  return RespondLater();
+}
+
+void EyeoDevToolsPrivateConnectFunction::RespondSocketConnected() {
+  Respond(NoArguments());
+}
+
+EyeoDevToolsPrivateConnectFunction::EyeoDevToolsPrivateConnectFunction() =
+    default;
+
+EyeoDevToolsPrivateConnectFunction::~EyeoDevToolsPrivateConnectFunction() =
+    default;
+
+ExtensionFunction::ResponseAction EyeoDevToolsPrivateDisconnectFunction::Run() {
+  auto* extension = EyeoDevToolsPrivateAPI::Get(browser_context());
+  auto& socket = extension->GetSocket();
+  std::string response;
+  if (SocketPtr(socket)) {
+    delete SocketPtr(socket);
+    response = SocketName(socket);
+    socket = std::make_tuple(nullptr, "", std::nullopt);
+  }
+  return RespondNow(ArgumentList(
+      eyeo_dev_tools_private::Disconnect::Results::Create(response)));
+}
+
+EyeoDevToolsPrivateDisconnectFunction::EyeoDevToolsPrivateDisconnectFunction() =
+    default;
+
+EyeoDevToolsPrivateDisconnectFunction::
+    ~EyeoDevToolsPrivateDisconnectFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoDevToolsPrivateRestartDiscoveryFunction::Run() {
+  auto* extension = EyeoDevToolsPrivateAPI::Get(browser_context());
+  extension->ClearRemoteTargets();
+  return RespondNow(NoArguments());
+}
+
+EyeoDevToolsPrivateRestartDiscoveryFunction::
+    EyeoDevToolsPrivateRestartDiscoveryFunction() = default;
+
+EyeoDevToolsPrivateRestartDiscoveryFunction::
+    ~EyeoDevToolsPrivateRestartDiscoveryFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoDevToolsPrivateSendRemoteCommandFunction::Run() {
+  std::optional<eyeo_dev_tools_private::SendRemoteCommand::Params> params(
+      eyeo_dev_tools_private::SendRemoteCommand::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto method = params->method;
+  auto params_json = params->params_json_string.value_or("");
+  auto* extension = EyeoDevToolsPrivateAPI::Get(browser_context());
+  auto& socket = extension->GetSocket();
+
+  if (!SocketPtr(socket)) {
+    return RespondNow(Error("Remote target not connected!"));
+  }
+
+  extension->SendMessage(
+      method, params_json,
+      base::BindOnce(
+          &EyeoDevToolsPrivateSendRemoteCommandFunction::RespondWithResult,
+          this));
+
+  return RespondLater();
+}
+
+void EyeoDevToolsPrivateSendRemoteCommandFunction::RespondWithResult(
+    const std::string& json_string) {
+  return Respond(ArgumentList(
+      eyeo_dev_tools_private::SendRemoteCommand::Results::Create(json_string)));
+}
+
+EyeoDevToolsPrivateSendRemoteCommandFunction::
+    EyeoDevToolsPrivateSendRemoteCommandFunction() = default;
+
+EyeoDevToolsPrivateSendRemoteCommandFunction::
+    ~EyeoDevToolsPrivateSendRemoteCommandFunction() = default;
+
+}  // namespace api
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h
new file mode 100644
index 0000000000000..ccb94d4ae3b80
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_api.h
@@ -0,0 +1,173 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_EYEO_DEV_TOOLS_PRIVATE_EYEO_DEV_TOOLS_PRIVATE_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_EYEO_DEV_TOOLS_PRIVATE_EYEO_DEV_TOOLS_PRIVATE_API_H_
+
+#include <tuple>
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/devtools/device/android_device_manager.h"
+#include "chrome/common/extensions/api/eyeo_dev_tools_private.h"
+#include "extensions/browser/browser_context_keyed_api_factory.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_function.h"
+
+namespace extensions {
+
+class EyeoDevToolsPrivateAPI
+    : public BrowserContextKeyedAPI,
+      public EventRouter::Observer,
+      public AndroidDeviceManager::AndroidWebSocket::Delegate {
+ public:
+  static BrowserContextKeyedAPIFactory<EyeoDevToolsPrivateAPI>*
+  GetFactoryInstance();
+
+  static EyeoDevToolsPrivateAPI* Get(content::BrowserContext* context);
+
+  explicit EyeoDevToolsPrivateAPI(content::BrowserContext* context);
+  ~EyeoDevToolsPrivateAPI() override;
+  friend class BrowserContextKeyedAPIFactory<EyeoDevToolsPrivateAPI>;
+
+  // BrowserContextKeyedAPI implementation.
+  static const char* service_name() { return "EyeoDevToolsPrivateAPI"; }
+  static const bool kServiceRedirectedInIncognito = true;
+  static const bool kServiceIsCreatedWithBrowserContext = true;
+  void Shutdown() override;
+
+  // EventRouter::Observer:
+  void OnListenerAdded(const extensions::EventListenerInfo& details) override;
+
+  // AndroidDeviceManager::AndroidWebSocket::Delegate
+  void OnSocketOpened() override;
+  void OnFrameRead(const std::string& message) override;
+  void OnSocketClosed() override;
+
+  // Socket pointer, socket name, and connection callback fired when socket is
+  // connected. When AndroidWebSocket ptr is null other tuple members are not
+  // important, this is enough to say there is no remote connection active.
+  // When AndroidWebSocket ptr is not null and connection callback is null
+  // it is assumed the callback has fired and socket is ready for messages.
+  typedef std::tuple<AndroidDeviceManager::AndroidWebSocket*,
+                     std::string,
+                     std::optional<base::OnceCallback<void()>>>
+      Socket;
+  Socket& GetSocket() { return socket_; }
+
+  // Map of remote targets to which we can connect to. Keys are socket names,
+  // values are Device objects required to establish a socket connection.
+  typedef std::map<std::string, scoped_refptr<AndroidDeviceManager::Device>>
+      RemoteTargets;
+  RemoteTargets& GetRemoteTargets() { return last_targets_; }
+  void ClearRemoteTargets() { return last_targets_.clear(); }
+
+  void SendMessage(const std::string& command,
+                   const std::string& params,
+                   base::OnceCallback<void(const std::string&)> callback);
+
+ private:
+  Socket socket_;
+  RemoteTargets last_targets_;
+  typedef std::map<int, base::OnceCallback<void(const std::string&)>>
+      MessagesInProgress;
+  MessagesInProgress messages_;
+  const raw_ptr<content::BrowserContext> context_;
+  class EyeoDevToolsAPIEventRouter;
+  std::unique_ptr<EyeoDevToolsAPIEventRouter> event_router_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoDevToolsPrivateAPI>::DeclareFactoryDependencies();
+
+namespace api {
+
+class EyeoDevToolsPrivateConnectFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoDevToolsPrivate.connect", UNKNOWN)
+  EyeoDevToolsPrivateConnectFunction();
+
+ private:
+  ~EyeoDevToolsPrivateConnectFunction() override;
+
+  ResponseAction Run() override;
+
+  void RespondSocketConnected();
+
+  EyeoDevToolsPrivateConnectFunction(
+      const EyeoDevToolsPrivateConnectFunction&) = delete;
+  EyeoDevToolsPrivateConnectFunction& operator=(
+      const EyeoDevToolsPrivateConnectFunction&) = delete;
+};
+
+class EyeoDevToolsPrivateDisconnectFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoDevToolsPrivate.disconnect", UNKNOWN)
+  EyeoDevToolsPrivateDisconnectFunction();
+
+ private:
+  ~EyeoDevToolsPrivateDisconnectFunction() override;
+
+  ResponseAction Run() override;
+
+  void RespondSocketConnected();
+
+  EyeoDevToolsPrivateDisconnectFunction(
+      const EyeoDevToolsPrivateDisconnectFunction&) = delete;
+  EyeoDevToolsPrivateDisconnectFunction& operator=(
+      const EyeoDevToolsPrivateDisconnectFunction&) = delete;
+};
+
+class EyeoDevToolsPrivateRestartDiscoveryFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoDevToolsPrivate.restartDiscovery", UNKNOWN)
+  EyeoDevToolsPrivateRestartDiscoveryFunction();
+
+ private:
+  ~EyeoDevToolsPrivateRestartDiscoveryFunction() override;
+
+  ResponseAction Run() override;
+
+  void RespondSocketConnected();
+
+  EyeoDevToolsPrivateRestartDiscoveryFunction(
+      const EyeoDevToolsPrivateRestartDiscoveryFunction&) = delete;
+  EyeoDevToolsPrivateRestartDiscoveryFunction& operator=(
+      const EyeoDevToolsPrivateRestartDiscoveryFunction&) = delete;
+};
+
+class EyeoDevToolsPrivateSendRemoteCommandFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoDevToolsPrivate.sendRemoteCommand", UNKNOWN)
+  EyeoDevToolsPrivateSendRemoteCommandFunction();
+
+ private:
+  ~EyeoDevToolsPrivateSendRemoteCommandFunction() override;
+
+  ResponseAction Run() override;
+
+  void RespondWithResult(const std::string& json_string);
+
+  EyeoDevToolsPrivateSendRemoteCommandFunction(
+      const EyeoDevToolsPrivateSendRemoteCommandFunction&) = delete;
+  EyeoDevToolsPrivateSendRemoteCommandFunction& operator=(
+      const EyeoDevToolsPrivateSendRemoteCommandFunction&) = delete;
+};
+
+}  // namespace api
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_EYEO_DEV_TOOLS_PRIVATE_EYEO_DEV_TOOLS_PRIVATE_API_H_
diff --git a/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_apitest.cc b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_apitest.cc
new file mode 100644
index 0000000000000..dc96a5f834ffd
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_dev_tools_private/eyeo_dev_tools_private_apitest.cc
@@ -0,0 +1,256 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/devtools/device/adb/adb_device_provider.h"
+#include "chrome/browser/devtools/device/adb/mock_adb_server.h"
+#include "chrome/browser/devtools/device/devtools_android_bridge.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "content/public/test/browser_test.h"
+#include "extensions/common/switches.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace extensions {
+
+namespace {
+void AllowTestExtension(base::CommandLine* command_line) {
+  command_line->AppendSwitchASCII(extensions::switches::kAllowlistedExtensionID,
+                                  "ocidpehmkefohkcpefepbccbliaipofj");
+}
+}  // namespace
+
+class EyeoDevToolsPrivateApiTest
+    : public ExtensionApiTest,
+      public DevToolsAndroidBridge::DeviceListListener {
+ public:
+  EyeoDevToolsPrivateApiTest() {}
+  ~EyeoDevToolsPrivateApiTest() override = default;
+  EyeoDevToolsPrivateApiTest(const EyeoDevToolsPrivateApiTest&) = delete;
+  EyeoDevToolsPrivateApiTest& operator=(const EyeoDevToolsPrivateApiTest&) =
+      delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    extensions::ExtensionApiTest::SetUpCommandLine(command_line);
+    AllowTestExtension(command_line);
+  }
+
+  void StartTest(base::RunLoop* loop) {
+    auto* android_bridge =
+        DevToolsAndroidBridge::Factory::GetForProfile(browser()->profile());
+    AndroidDeviceManager::DeviceProviders device_providers;
+    device_providers.push_back(new AdbDeviceProvider());
+    android_bridge->set_device_providers_for_test(device_providers);
+    android_bridge->AddDeviceListListener(this);
+    loop_ = loop;
+    loop_->Run();
+  }
+
+  void DeviceListChanged(
+      const DevToolsAndroidBridge::RemoteDevices& devices) override {
+    // Devices count is fixed in MockAdbServer
+    if (devices.size() == 2) {
+      auto* android_bridge =
+          DevToolsAndroidBridge::Factory::GetForProfile(browser()->profile());
+      android_bridge->RemoveDeviceListListener(this);
+      loop_->QuitWhenIdle();
+    }
+  }
+
+  int ExecuteScriptAndGetInt(const std::string& extension_id,
+                             const std::string& script) {
+    return ExtensionApiTest::ExecuteScriptInBackgroundPage(extension_id, script)
+        .GetInt();
+  }
+
+  const ExtensionId& GetExtensionId() const { return extension_->id(); }
+
+ protected:
+  raw_ptr<base::RunLoop> loop_;
+  raw_ptr<const Extension, DanglingUntriaged> extension_;
+};
+
+IN_PROC_BROWSER_TEST_F(EyeoDevToolsPrivateApiTest, DiscoverRemoteTargets) {
+  extension_ =
+      LoadExtension(test_data_dir_.AppendASCII("eyeo_dev_tools_private"));
+  ASSERT_TRUE(extension_);
+
+  constexpr char discovery_script[] = R"(
+      let testData = {};
+      testData.foundCount = 0;
+      testData.lostCount = 0;
+      chrome.eyeoDevToolsPrivate.onRemoteTargetFound.addListener((info) => {
+        console.log("Found: " + JSON.stringify(info));
+        testData.foundCount = testData.foundCount + 1;
+      });
+      chrome.eyeoDevToolsPrivate.onRemoteTargetLost.addListener((info) => {
+        console.log("Lost: " + JSON.stringify(info));
+        testData.lostCount = testData.lostCount + 1;
+      });
+      chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char verify_counters_tmpl[] = R"(
+        var intervalId = setInterval(function() {
+          let result = testData.%s;
+          if (result == 4) {
+            if (intervalId) {
+              clearInterval(intervalId);
+              intervalId = null;
+            }
+            chrome.test.sendScriptResult(result);
+          }
+        }, 100);
+  )";
+
+  EXPECT_EQ(0, ExecuteScriptAndGetInt(GetExtensionId(), discovery_script));
+  base::RunLoop loop;
+  StartMockAdbServer(FlushWithoutSize);
+  StartTest(&loop);
+  StopMockAdbServer();
+
+  // Hardcoded data in MockAdbServer contains 4 remote "page" targets
+  EXPECT_EQ(4, ExecuteScriptAndGetInt(
+                   GetExtensionId(),
+                   base::StringPrintf(verify_counters_tmpl, "foundCount")));
+  EXPECT_EQ(4, ExecuteScriptAndGetInt(
+                   GetExtensionId(),
+                   base::StringPrintf(verify_counters_tmpl, "lostCount")));
+}
+
+// This test fails with MockAdbServer but passes with a remote WebViewShell app
+// running on emulator.
+IN_PROC_BROWSER_TEST_F(EyeoDevToolsPrivateApiTest,
+                       DISABLED_ConnectToRemoteTarget) {
+  extension_ =
+      LoadExtension(test_data_dir_.AppendASCII("eyeo_dev_tools_private"));
+  ASSERT_TRUE(extension_);
+
+  constexpr char connect_script[] = R"(
+      let selected = false;
+      chrome.eyeoDevToolsPrivate.onRemoteTargetFound.addListener((info) => {
+          if (selected) {
+            return;
+          }
+          selected = true;
+          console.log("Found: " + JSON.stringify(info));
+          chrome.eyeoDevToolsPrivate.connect(info.socket_name, () => {
+              if (chrome.runtime.lastError) {
+                console.log(chrome.runtime.lastError.message);
+                chrome.test.sendScriptResult(1);
+                return;
+              }
+              console.log("Connected to: " + info.socket_name);
+              // Confirm that 2nd connection attempt is rejected
+              chrome.eyeoDevToolsPrivate.connect(info.socket_name, () => {
+                  if (!chrome.runtime.lastError) {
+                    chrome.test.sendScriptResult(2);
+                    return;
+                  }
+                  console.log(chrome.runtime.lastError.message);
+                  chrome.eyeoDevToolsPrivate.disconnect((socket_name) => {
+                      if (!socket_name || (socket_name != info.socket_name)) {
+                        console.log(chrome.runtime.lastError.message);
+                        chrome.test.sendScriptResult(3);
+                        return;
+                      }
+                      console.log("Disconnected from: " + info.socket_name);
+                      // Confirm that now 2nd connection attempt is granted
+                      chrome.eyeoDevToolsPrivate.connect(info.socket_name, () => {
+                          if (chrome.runtime.lastError) {
+                            console.log(chrome.runtime.lastError.message);
+                            chrome.test.sendScriptResult(4);
+                            return;
+                          }
+                          console.log("Connected again to: " + info.socket_name);
+                          chrome.test.sendScriptResult(0);
+                      });
+                  });
+              });
+          });
+      });
+  )";
+
+  EXPECT_EQ(0, ExecuteScriptAndGetInt(GetExtensionId(), connect_script));
+}
+
+// This test fails with MockAdbServer but passes with a remote WebViewShell app
+// running on emulator.
+IN_PROC_BROWSER_TEST_F(EyeoDevToolsPrivateApiTest,
+                       DISABLED_SendCommandToRemoteTarget) {
+  extension_ =
+      LoadExtension(test_data_dir_.AppendASCII("eyeo_dev_tools_private"));
+  ASSERT_TRUE(extension_);
+
+  constexpr char command_script[] = R"(
+      let selected = false;
+      chrome.eyeoDevToolsPrivate.onRemoteTargetFound.addListener((info) => {
+          if (selected) {
+            return;
+          }
+          selected = true;
+          console.log("Found: " + JSON.stringify(info));
+          chrome.eyeoDevToolsPrivate.connect(info.socket_name, () => {
+              console.log("Connected: " + info.socket_name);
+              chrome.eyeoDevToolsPrivate.sendRemoteCommand("addCustomFilter", "{\"filter\": \"dummy\"}", (result) => {
+                  if (chrome.runtime.lastError) {
+                    console.log(chrome.runtime.lastError.message);
+                    chrome.test.sendScriptResult(1);
+                    return;
+                  }
+                  console.log("Command output: " + result);
+                  chrome.eyeoDevToolsPrivate.sendRemoteCommand("getCustomFilters", (result) => {
+                      if (chrome.runtime.lastError) {
+                        console.log(chrome.runtime.lastError.message);
+                        chrome.test.sendScriptResult(2);
+                        return;
+                      }
+                      console.log("Command output: " + result);
+                      if (result !== "{\"id\":1,\"result\":{\"filters\":[\"dummy\"]}}") {
+                        chrome.test.sendScriptResult(3);
+                        return;
+                      }
+                      chrome.eyeoDevToolsPrivate.sendRemoteCommand("removeCustomFilter", "{\"filter\": \"dummy\"}", (result) => {
+                          if (chrome.runtime.lastError) {
+                            console.log(chrome.runtime.lastError.message);
+                            chrome.test.sendScriptResult(4);
+                            return;
+                          }
+                          console.log("Command output: " + result);
+                          chrome.eyeoDevToolsPrivate.sendRemoteCommand("getCustomFilters", (result) => {
+                              if (chrome.runtime.lastError) {
+                                console.log(chrome.runtime.lastError.message);
+                                chrome.test.sendScriptResult(5);
+                                return;
+                              }
+                              console.log("Command output: " + result);
+                              if (result !== "{\"id\":3,\"result\":{\"filters\":[]}}") {
+                                chrome.test.sendScriptResult(6);
+                                return;
+                              }
+                              chrome.test.sendScriptResult(0);
+                          });
+                      });
+                  });
+              });
+          });
+      });
+  )";
+
+  EXPECT_EQ(0, ExecuteScriptAndGetInt(GetExtensionId(), command_script));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
new file mode 100644
index 0000000000000..533456160beec
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
@@ -0,0 +1,855 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h"
+
+#include "base/containers/flat_map.h"
+#include "base/i18n/time_formatting.h"
+#include "base/no_destructor.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/common/adblock_utils.h"
+#include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/configuration/filtering_configuration.h"
+#include "components/adblock/core/configuration/persistent_filtering_configuration.h"
+#include "components/adblock/core/session_stats.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/prefs/pref_service.h"
+#include "components/sessions/core/session_id.h"
+#include "content/public/browser/web_contents.h"
+#include "url/gurl.h"
+namespace extensions {
+
+namespace {
+
+constexpr char kConfigurationMissing[] =
+    "Configuration with name '%s' does not exist!";
+
+adblock::FilteringConfiguration* FindFilteringConfiguration(
+    content::BrowserContext* context,
+    const std::string& config_name) {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(context);
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, config_name,
+                        &adblock::FilteringConfiguration::GetName);
+  return configuration_it != installed_configurations.end() ? *configuration_it
+                                                            : nullptr;
+}
+
+enum class SubscriptionAction { kInstall, kUninstall };
+
+std::string RunSubscriptionAction(
+    adblock::FilteringConfiguration* configuration,
+    SubscriptionAction action,
+    const GURL& url) {
+  if (!url.is_valid()) {
+    return "Invalid URL";
+  }
+  switch (action) {
+    case SubscriptionAction::kInstall:
+      configuration->AddFilterList(url);
+      break;
+    case SubscriptionAction::kUninstall:
+      configuration->RemoveFilterList(url);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  return {};
+}
+
+std::vector<api::eyeo_filtering_private::SessionStatsEntry> CopySessionsStats(
+    const std::map<GURL, long>& source) {
+  std::vector<api::eyeo_filtering_private::SessionStatsEntry> result;
+  for (auto& entry : source) {
+    api::eyeo_filtering_private::SessionStatsEntry js_entry;
+    js_entry.url = entry.first.spec();
+    js_entry.count = entry.second;
+    result.emplace_back(std::move(js_entry));
+  }
+  return result;
+}
+
+std::string SubscriptionInstallationStateToString(
+    adblock::Subscription::InstallationState state) {
+  using State = adblock::Subscription::InstallationState;
+  switch (state) {
+    case State::Installed:
+      return "Installed";
+    case State::AutoInstalled:
+      return "AutoInstalled";
+    case State::Preloaded:
+      return "Preloaded";
+    case State::Installing:
+      return "Installing";
+    case State::Unknown:
+      return "Unknown";
+  }
+  return "";
+}
+
+std::vector<api::eyeo_filtering_private::Subscription> CopySubscriptions(
+    const std::vector<scoped_refptr<adblock::Subscription>>
+        current_subscriptions) {
+  std::vector<api::eyeo_filtering_private::Subscription> result;
+  for (auto& sub : current_subscriptions) {
+    api::eyeo_filtering_private::Subscription js_sub;
+    js_sub.url = sub->GetSourceUrl().spec();
+    js_sub.title = sub->GetTitle();
+    js_sub.current_version = sub->GetCurrentVersion();
+    js_sub.installation_state =
+        SubscriptionInstallationStateToString(sub->GetInstallationState());
+    const auto installation_time = sub->GetInstallationTime();
+    js_sub.last_installation_time =
+        installation_time.is_null()
+            ? ""
+            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+    result.emplace_back(std::move(js_sub));
+  }
+  return result;
+}
+
+content::BrowserContext* GetOriginalBrowserContext(
+    content::BrowserContext* browser_context) {
+  return Profile::FromBrowserContext(browser_context)->GetOriginalProfile();
+}
+
+}  // namespace
+
+class EyeoFilteringPrivateAPI::EyeoFilteringAPIEventRouter
+    : public adblock::ResourceClassificationRunner::Observer,
+      public adblock::SubscriptionService::SubscriptionObserver,
+      public adblock::FilteringConfiguration::Observer {
+ public:
+  explicit EyeoFilteringAPIEventRouter(content::BrowserContext* context)
+      : context_(GetOriginalBrowserContext(context)) {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->AddObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->AddObserver(this);
+    for (auto* it :
+         subscription_service->GetInstalledFilteringConfigurations()) {
+      it->AddObserver(this);
+    }
+  }
+
+  ~EyeoFilteringAPIEventRouter() override {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->RemoveObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->RemoveObserver(this);
+    for (auto* it :
+         subscription_service->GetInstalledFilteringConfigurations()) {
+      it->RemoveObserver(this);
+    }
+  }
+
+  // adblock::ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        adblock::FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        adblock::ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = adblock::utils::ConvertURLs(parent_frame_urls);
+    info.content_type = adblock::ContentTypeToString(content_type);
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnRequestBlocked::kEventName,
+          api::eyeo_filtering_private::OnRequestBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnRequestAllowed::kEventName,
+          api::eyeo_filtering_private::OnRequestAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{};
+    info.content_type = "";
+
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnPageAllowed::kEventName,
+        api::eyeo_filtering_private::OnPageAllowed::Create(info));
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      adblock::FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{opener_url.spec()};
+    info.content_type = "";
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnPopupBlocked::kEventName,
+          api::eyeo_filtering_private::OnPopupBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnPopupAllowed::kEventName,
+          api::eyeo_filtering_private::OnPopupAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPageElementMatched(
+      const std::string& selector,
+      adblock::ElementHideAction action,
+      content::RenderFrameHost* render_frame_host) override {
+    api::eyeo_filtering_private::PageElementInfo info =
+        CreatePageElementInfoObject(selector, action, render_frame_host);
+
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnPageElementMatched::kEventName,
+        api::eyeo_filtering_private::OnPageElementMatched::Create(info));
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::SubscriptionService::SubscriptionObserver:
+  void OnSubscriptionInstalled(const GURL& url) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnSubscriptionUpdated::kEventName,
+        api::eyeo_filtering_private::OnSubscriptionUpdated::Create(url.spec()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilteringConfigurationInstalled(
+      adblock::FilteringConfiguration* config) override {
+    config->AddObserver(this);
+  }
+
+  // adblock::FilteringConfiguration::Observer:
+  void OnEnabledStateChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnEnabledStateChanged::kEventName,
+        api::eyeo_filtering_private::OnEnabledStateChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilterListsChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnFilterListsChanged::kEventName,
+        api::eyeo_filtering_private::OnFilterListsChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnAllowedDomainsChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnAllowedDomainsChanged::kEventName,
+        api::eyeo_filtering_private::OnAllowedDomainsChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnCustomFiltersChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnCustomFiltersChanged::kEventName,
+        api::eyeo_filtering_private::OnCustomFiltersChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+ private:
+  api::eyeo_filtering_private::RequestInfo CreateRequestInfoObject(
+      const GURL& url,
+      const GURL& subscription,
+      const std::string& configuration_name,
+      content::RenderFrameHost* render_frame_host) {
+    DCHECK(render_frame_host);
+    api::eyeo_filtering_private::RequestInfo info;
+    info.url = url.spec();
+    info.subscription = subscription.spec();
+    info.configuration_name = configuration_name;
+    info.tab_id = api::tabs::TAB_ID_NONE;
+    info.window_id = SessionID::InvalidValue().id();
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (wc) {
+      info.tab_id = ExtensionTabUtil::GetTabId(wc);
+      info.window_id = ExtensionTabUtil::GetWindowIdOfTab(wc);
+    }
+    return info;
+  }
+
+  api::eyeo_filtering_private::PageElementInfo CreatePageElementInfoObject(
+      const std::string& selector,
+      adblock::ElementHideAction action,
+      content::RenderFrameHost* render_frame_host) {
+    DCHECK(render_frame_host);
+    api::eyeo_filtering_private::PageElementInfo info;
+    info.selector = selector;
+    info.action =
+        static_cast<api::eyeo_filtering_private::ElementHideAction>(action);
+    info.tab_id = api::tabs::TAB_ID_NONE;
+    info.window_id = SessionID::InvalidValue().id();
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (wc) {
+      info.tab_id = ExtensionTabUtil::GetTabId(wc);
+      info.window_id = ExtensionTabUtil::GetWindowIdOfTab(wc);
+    }
+    return info;
+  }
+
+  const raw_ptr<content::BrowserContext> context_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoFilteringPrivateAPI>::DeclareFactoryDependencies() {
+  DependsOn(adblock::SubscriptionServiceFactory::GetInstance());
+}
+
+// static
+BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>*
+EyeoFilteringPrivateAPI::GetFactoryInstance() {
+  static base::NoDestructor<
+      BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>>
+      instance;
+  return instance.get();
+}
+
+// static
+EyeoFilteringPrivateAPI* EyeoFilteringPrivateAPI::Get(
+    content::BrowserContext* context) {
+  return GetFactoryInstance()->Get(context);
+}
+
+EyeoFilteringPrivateAPI::EyeoFilteringPrivateAPI(
+    content::BrowserContext* context)
+    : context_(context) {
+  // EventRouter can be null in tests
+  auto* ev = EventRouter::Get(context_);
+  if (ev) {
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnRequestAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnRequestBlocked::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPageAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPopupAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPopupBlocked::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnSubscriptionUpdated::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnEnabledStateChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnFilterListsChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnAllowedDomainsChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnCustomFiltersChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPageElementMatched::kEventName);
+  }
+  // Make sure SessionStats is created so it will start collectings stats
+  adblock::SessionStatsFactory::GetForBrowserContext(context);
+}
+
+EyeoFilteringPrivateAPI::~EyeoFilteringPrivateAPI() = default;
+
+void EyeoFilteringPrivateAPI::Shutdown() {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->UnregisterObserver(this);
+  }
+  event_router_.reset();
+}
+
+void EyeoFilteringPrivateAPI::OnListenerAdded(
+    const extensions::EventListenerInfo& details) {
+  event_router_ =
+      std::make_unique<EyeoFilteringPrivateAPI::EyeoFilteringAPIEventRouter>(
+          context_);
+  EventRouter::Get(context_)->UnregisterObserver(this);
+}
+
+namespace api {
+
+EyeoFilteringPrivateCreateConfigurationFunction::
+    EyeoFilteringPrivateCreateConfigurationFunction() = default;
+
+EyeoFilteringPrivateCreateConfigurationFunction::
+    ~EyeoFilteringPrivateCreateConfigurationFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateCreateConfigurationFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::CreateConfiguration::Params>
+      params(api::eyeo_filtering_private::CreateConfiguration::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, params->config_name,
+                        &adblock::FilteringConfiguration::GetName);
+  if (configuration_it == installed_configurations.end()) {
+    auto new_filtering_configuration =
+        std::make_unique<adblock::PersistentFilteringConfiguration>(
+            Profile::FromBrowserContext(
+                GetOriginalBrowserContext(browser_context()))
+                ->GetPrefs(),
+            params->config_name);
+    subscription_service->InstallFilteringConfiguration(
+        std::move(new_filtering_configuration));
+  }
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveConfigurationFunction::
+    EyeoFilteringPrivateRemoveConfigurationFunction() = default;
+
+EyeoFilteringPrivateRemoveConfigurationFunction::
+    ~EyeoFilteringPrivateRemoveConfigurationFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveConfigurationFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveConfiguration::Params>
+      params(api::eyeo_filtering_private::RemoveConfiguration::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, params->config_name,
+                        &adblock::FilteringConfiguration::GetName);
+  if (configuration_it != installed_configurations.end()) {
+    subscription_service->UninstallFilteringConfiguration(
+        std::string((*configuration_it)->GetName()));
+  }
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetConfigurationsFunction::
+    EyeoFilteringPrivateGetConfigurationsFunction() = default;
+
+EyeoFilteringPrivateGetConfigurationsFunction::
+    ~EyeoFilteringPrivateGetConfigurationsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetConfigurationsFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  std::vector<std::string> configurations;
+  std::ranges::transform(installed_configurations,
+                         std::back_inserter(configurations),
+                         [](adblock::FilteringConfiguration* config) {
+                           return config->GetName();
+                         });
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetConfigurations::Results::Create(
+          std::move(configurations))));
+}
+
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::
+    EyeoFilteringPrivateSetAutoInstallEnabledFunction() {}
+
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::
+    ~EyeoFilteringPrivateSetAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::SetAutoInstallEnabled::Params>
+      params =
+          api::eyeo_filtering_private::SetAutoInstallEnabled::Params::Create(
+              args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  subscription_service->SetAutoInstallEnabled(params->enabled);
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::
+    EyeoFilteringPrivateIsAutoInstallEnabledFunction() {}
+
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::
+    ~EyeoFilteringPrivateIsAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::IsAutoInstallEnabled::Results::Create(
+          subscription_service->IsAutoInstallEnabled())));
+}
+
+EyeoFilteringPrivateSetEnabledFunction::
+    EyeoFilteringPrivateSetEnabledFunction() = default;
+
+EyeoFilteringPrivateSetEnabledFunction::
+    ~EyeoFilteringPrivateSetEnabledFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateSetEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::SetEnabled::Params> params(
+      api::eyeo_filtering_private::SetEnabled::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->SetEnabled(params->enabled);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateIsEnabledFunction::EyeoFilteringPrivateIsEnabledFunction() {
+}
+
+EyeoFilteringPrivateIsEnabledFunction::
+    ~EyeoFilteringPrivateIsEnabledFunction() = default;
+
+ExtensionFunction::ResponseAction EyeoFilteringPrivateIsEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::IsEnabled::Params> params(
+      api::eyeo_filtering_private::IsEnabled::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::IsEnabled::Results::Create(
+          configuration->IsEnabled())));
+}
+
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::
+    EyeoFilteringPrivateGetAcceptableAdsUrlFunction() = default;
+
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::
+    ~EyeoFilteringPrivateGetAcceptableAdsUrlFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::Run() {
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetAcceptableAdsUrl::Results::Create(
+          adblock::AcceptableAdsUrl().spec())));
+}
+
+EyeoFilteringPrivateAddFilterListFunction::
+    EyeoFilteringPrivateAddFilterListFunction() = default;
+
+EyeoFilteringPrivateAddFilterListFunction::
+    ~EyeoFilteringPrivateAddFilterListFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddFilterListFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddFilterList::Params> params(
+      api::eyeo_filtering_private::AddFilterList::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(configuration, SubscriptionAction::kInstall, url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveFilterListFunction::
+    EyeoFilteringPrivateRemoveFilterListFunction() = default;
+
+EyeoFilteringPrivateRemoveFilterListFunction::
+    ~EyeoFilteringPrivateRemoveFilterListFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveFilterListFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveFilterList::Params> params(
+      api::eyeo_filtering_private::RemoveFilterList::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(configuration, SubscriptionAction::kUninstall, url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetFilterListsFunction::
+    EyeoFilteringPrivateGetFilterListsFunction() = default;
+
+EyeoFilteringPrivateGetFilterListsFunction::
+    ~EyeoFilteringPrivateGetFilterListsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetFilterListsFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetFilterLists::Params> params(
+      api::eyeo_filtering_private::GetFilterLists::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetFilterLists::Results::Create(
+          CopySubscriptions(
+              subscription_service->GetCurrentSubscriptions(configuration)))));
+}
+
+EyeoFilteringPrivateAddAllowedDomainFunction::
+    EyeoFilteringPrivateAddAllowedDomainFunction() = default;
+
+EyeoFilteringPrivateAddAllowedDomainFunction::
+    ~EyeoFilteringPrivateAddAllowedDomainFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddAllowedDomainFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddAllowedDomain::Params> params(
+      api::eyeo_filtering_private::AddAllowedDomain::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->AddAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveAllowedDomainFunction::
+    EyeoFilteringPrivateRemoveAllowedDomainFunction() = default;
+
+EyeoFilteringPrivateRemoveAllowedDomainFunction::
+    ~EyeoFilteringPrivateRemoveAllowedDomainFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveAllowedDomainFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveAllowedDomain::Params>
+      params(api::eyeo_filtering_private::RemoveAllowedDomain::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->RemoveAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetAllowedDomainsFunction::
+    EyeoFilteringPrivateGetAllowedDomainsFunction() = default;
+
+EyeoFilteringPrivateGetAllowedDomainsFunction::
+    ~EyeoFilteringPrivateGetAllowedDomainsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetAllowedDomainsFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetAllowedDomains::Params> params(
+      api::eyeo_filtering_private::GetAllowedDomains::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetCustomFilters::Results::Create(
+          configuration->GetAllowedDomains())));
+}
+
+EyeoFilteringPrivateAddCustomFilterFunction::
+    EyeoFilteringPrivateAddCustomFilterFunction() = default;
+
+EyeoFilteringPrivateAddCustomFilterFunction::
+    ~EyeoFilteringPrivateAddCustomFilterFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddCustomFilterFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddCustomFilter::Params> params(
+      api::eyeo_filtering_private::AddCustomFilter::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->AddCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveCustomFilterFunction::
+    EyeoFilteringPrivateRemoveCustomFilterFunction() = default;
+
+EyeoFilteringPrivateRemoveCustomFilterFunction::
+    ~EyeoFilteringPrivateRemoveCustomFilterFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveCustomFilterFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveCustomFilter::Params>
+      params(api::eyeo_filtering_private::RemoveCustomFilter::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->RemoveCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetCustomFiltersFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetCustomFilters::Params> params(
+      api::eyeo_filtering_private::GetCustomFilters::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetCustomFilters::Results::Create(
+          configuration->GetCustomFilters())));
+}
+
+EyeoFilteringPrivateGetCustomFiltersFunction::
+    EyeoFilteringPrivateGetCustomFiltersFunction() = default;
+
+EyeoFilteringPrivateGetCustomFiltersFunction::
+    ~EyeoFilteringPrivateGetCustomFiltersFunction() = default;
+
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::
+    EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() = default;
+
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::
+    ~EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::Run() {
+  auto* session_stats = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetSessionAllowedRequestsCount::
+                       Results::Create(CopySessionsStats(
+                           session_stats->GetSessionAllowedResourcesCount()))));
+}
+
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::
+    EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() = default;
+
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::
+    ~EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::Run() {
+  auto* session_stats = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetSessionBlockedRequestsCount::
+                       Results::Create(CopySessionsStats(
+                           session_stats->GetSessionBlockedResourcesCount()))));
+}
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
new file mode 100644
index 0000000000000..4add7f11d9072
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
@@ -0,0 +1,392 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/common/extensions/api/eyeo_filtering_private.h"
+#include "extensions/browser/browser_context_keyed_api_factory.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_function.h"
+
+namespace extensions {
+
+class EyeoFilteringPrivateAPI : public BrowserContextKeyedAPI,
+                                public EventRouter::Observer {
+ public:
+  static BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>*
+  GetFactoryInstance();
+
+  static EyeoFilteringPrivateAPI* Get(content::BrowserContext* context);
+
+  explicit EyeoFilteringPrivateAPI(content::BrowserContext* context);
+  ~EyeoFilteringPrivateAPI() override;
+  friend class BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>;
+
+  // BrowserContextKeyedAPI implementation.
+  static const char* service_name() { return "EyeoFilteringPrivateAPI"; }
+  static const bool kServiceRedirectedInIncognito = true;
+  static const bool kServiceIsCreatedWithBrowserContext = true;
+  void Shutdown() override;
+
+  // EventRouter::Observer:
+  void OnListenerAdded(const extensions::EventListenerInfo& details) override;
+
+ private:
+  const raw_ptr<content::BrowserContext> context_;
+  class EyeoFilteringAPIEventRouter;
+  std::unique_ptr<EyeoFilteringAPIEventRouter> event_router_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoFilteringPrivateAPI>::DeclareFactoryDependencies();
+
+namespace api {
+
+class EyeoFilteringPrivateCreateConfigurationFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.createConfiguration",
+                             UNKNOWN)
+  EyeoFilteringPrivateCreateConfigurationFunction();
+
+ private:
+  ~EyeoFilteringPrivateCreateConfigurationFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateCreateConfigurationFunction(
+      const EyeoFilteringPrivateCreateConfigurationFunction&) = delete;
+  EyeoFilteringPrivateCreateConfigurationFunction& operator=(
+      const EyeoFilteringPrivateCreateConfigurationFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveConfigurationFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeConfiguration",
+                             UNKNOWN)
+  EyeoFilteringPrivateRemoveConfigurationFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveConfigurationFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveConfigurationFunction(
+      const EyeoFilteringPrivateRemoveConfigurationFunction&) = delete;
+  EyeoFilteringPrivateRemoveConfigurationFunction& operator=(
+      const EyeoFilteringPrivateRemoveConfigurationFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetConfigurationsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getConfigurations", UNKNOWN)
+  EyeoFilteringPrivateGetConfigurationsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetConfigurationsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetConfigurationsFunction(
+      const EyeoFilteringPrivateGetConfigurationsFunction&) = delete;
+  EyeoFilteringPrivateGetConfigurationsFunction& operator=(
+      const EyeoFilteringPrivateGetConfigurationsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateSetAutoInstallEnabledFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.setAutoInstallEnabled",
+                             UNKNOWN)
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateSetAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction(
+      const EyeoFilteringPrivateSetAutoInstallEnabledFunction&) = delete;
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction& operator=(
+      const EyeoFilteringPrivateSetAutoInstallEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateIsAutoInstallEnabledFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.isAutoInstallEnabled",
+                             UNKNOWN)
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateIsAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction(
+      const EyeoFilteringPrivateIsAutoInstallEnabledFunction&) = delete;
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction& operator=(
+      const EyeoFilteringPrivateIsAutoInstallEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateSetEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.setEnabled", UNKNOWN)
+  EyeoFilteringPrivateSetEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateSetEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateSetEnabledFunction(
+      const EyeoFilteringPrivateSetEnabledFunction&) = delete;
+  EyeoFilteringPrivateSetEnabledFunction& operator=(
+      const EyeoFilteringPrivateSetEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateIsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.isEnabled", UNKNOWN)
+  EyeoFilteringPrivateIsEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateIsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateIsEnabledFunction(
+      const EyeoFilteringPrivateIsEnabledFunction&) = delete;
+  EyeoFilteringPrivateIsEnabledFunction& operator=(
+      const EyeoFilteringPrivateIsEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetAcceptableAdsUrlFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getAcceptableAdsUrl",
+                             UNKNOWN)
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetAcceptableAdsUrlFunction() override;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction(
+      const EyeoFilteringPrivateGetAcceptableAdsUrlFunction&) = delete;
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction& operator=(
+      const EyeoFilteringPrivateGetAcceptableAdsUrlFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddFilterListFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addFilterList", UNKNOWN)
+  EyeoFilteringPrivateAddFilterListFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddFilterListFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddFilterListFunction(
+      const EyeoFilteringPrivateAddFilterListFunction&) = delete;
+  EyeoFilteringPrivateAddFilterListFunction& operator=(
+      const EyeoFilteringPrivateAddFilterListFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveFilterListFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeFilterList", UNKNOWN)
+  EyeoFilteringPrivateRemoveFilterListFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveFilterListFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveFilterListFunction(
+      const EyeoFilteringPrivateRemoveFilterListFunction&) = delete;
+  EyeoFilteringPrivateRemoveFilterListFunction& operator=(
+      const EyeoFilteringPrivateRemoveFilterListFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetFilterListsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getFilterLists", UNKNOWN)
+  EyeoFilteringPrivateGetFilterListsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetFilterListsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetFilterListsFunction(
+      const EyeoFilteringPrivateGetFilterListsFunction&) = delete;
+  EyeoFilteringPrivateGetFilterListsFunction& operator=(
+      const EyeoFilteringPrivateGetFilterListsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addAllowedDomain", UNKNOWN)
+  EyeoFilteringPrivateAddAllowedDomainFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddAllowedDomainFunction(
+      const EyeoFilteringPrivateAddAllowedDomainFunction&) = delete;
+  EyeoFilteringPrivateAddAllowedDomainFunction& operator=(
+      const EyeoFilteringPrivateAddAllowedDomainFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveAllowedDomainFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeAllowedDomain",
+                             UNKNOWN)
+  EyeoFilteringPrivateRemoveAllowedDomainFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveAllowedDomainFunction(
+      const EyeoFilteringPrivateRemoveAllowedDomainFunction&) = delete;
+  EyeoFilteringPrivateRemoveAllowedDomainFunction& operator=(
+      const EyeoFilteringPrivateRemoveAllowedDomainFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetAllowedDomainsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getAllowedDomains", UNKNOWN)
+  EyeoFilteringPrivateGetAllowedDomainsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetAllowedDomainsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetAllowedDomainsFunction(
+      const EyeoFilteringPrivateGetAllowedDomainsFunction&) = delete;
+  EyeoFilteringPrivateGetAllowedDomainsFunction& operator=(
+      const EyeoFilteringPrivateGetAllowedDomainsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addCustomFilter", UNKNOWN)
+  EyeoFilteringPrivateAddCustomFilterFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddCustomFilterFunction(
+      const EyeoFilteringPrivateAddCustomFilterFunction&) = delete;
+  EyeoFilteringPrivateAddCustomFilterFunction& operator=(
+      const EyeoFilteringPrivateAddCustomFilterFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveCustomFilterFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeCustomFilter", UNKNOWN)
+  EyeoFilteringPrivateRemoveCustomFilterFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveCustomFilterFunction(
+      const EyeoFilteringPrivateRemoveCustomFilterFunction&) = delete;
+  EyeoFilteringPrivateRemoveCustomFilterFunction& operator=(
+      const EyeoFilteringPrivateRemoveCustomFilterFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetCustomFiltersFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getCustomFilters", UNKNOWN)
+  EyeoFilteringPrivateGetCustomFiltersFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetCustomFiltersFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetCustomFiltersFunction(
+      const EyeoFilteringPrivateGetCustomFiltersFunction&) = delete;
+  EyeoFilteringPrivateGetCustomFiltersFunction& operator=(
+      const EyeoFilteringPrivateGetCustomFiltersFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "eyeoFilteringPrivate.getSessionAllowedRequestsCount",
+      UNKNOWN)
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction(
+      const EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction&) =
+      delete;
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction& operator=(
+      const EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction&) =
+      delete;
+};
+
+class EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "eyeoFilteringPrivate.getSessionBlockedRequestsCount",
+      UNKNOWN)
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction(
+      const EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction&) =
+      delete;
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction& operator=(
+      const EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction&) =
+      delete;
+};
+
+}  // namespace api
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc
new file mode 100644
index 0000000000000..13919fa3825b6
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc
@@ -0,0 +1,172 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "extensions/common/switches.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace extensions {
+
+namespace {
+enum class Mode { Normal, Incognito };
+
+void AllowTestExtension(base::CommandLine* command_line) {
+  command_line->AppendSwitchASCII(extensions::switches::kAllowlistedExtensionID,
+                                  "hjlolhdkflcejcekagdgahplimkppjml");
+}
+
+void EnableIncognitoMode(base::CommandLine* command_line) {
+  command_line->AppendSwitch(::switches::kIncognito);
+}
+}  // namespace
+
+class EyeoFilteringPrivateApiTest : public ExtensionApiTest,
+                                    public testing::WithParamInterface<Mode> {
+ public:
+  EyeoFilteringPrivateApiTest() {}
+  ~EyeoFilteringPrivateApiTest() override = default;
+  EyeoFilteringPrivateApiTest(const EyeoFilteringPrivateApiTest&) = delete;
+  EyeoFilteringPrivateApiTest& operator=(const EyeoFilteringPrivateApiTest&) =
+      delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    extensions::ExtensionApiTest::SetUpCommandLine(command_line);
+    AllowTestExtension(command_line);
+    if (IsIncognito()) {
+      EnableIncognitoMode(command_line);
+    }
+  }
+
+ protected:
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+
+    auto* adblock_configuration =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile())
+            ->GetFilteringConfiguration(
+                adblock::kAdblockFilteringConfigurationName);
+    if (adblock_configuration) {
+      adblock_configuration->RemoveCustomFilter(
+          adblock::kAllowlistEverythingFilter);
+    }
+
+    AdblockChromeContentBrowserClient::ForceAdblockProxyForTesting();
+  }
+
+  bool IsIncognito() { return GetParam() == Mode::Incognito; }
+
+  bool RunTest(const std::string& subtest) {
+    const std::string page_url = "main.html?subtest=" + subtest;
+    return RunExtensionTest("eyeo_filtering_private",
+                            {.extension_url = page_url.c_str()},
+                            {.allow_in_incognito = IsIncognito(),
+                             .load_as_component = !IsIncognito()});
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       CreateRemoveAndGetConfigurations) {
+  EXPECT_TRUE(RunTest("createRemoveAndGetConfigurations")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       CreateRemoveAndGetConfigurationsWithPromises) {
+  EXPECT_TRUE(RunTest("createRemoveAndGetConfigurationsWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       EnableAndDisableConfiguration) {
+  EXPECT_TRUE(RunTest("enableAndDisableConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       EnableAndDisableConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("enableAndDisableConfigurationWithPromises")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddAllowedDomainToCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addAllowedDomainToCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddAllowedDomainToCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addAllowedDomainToCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddCustomFilterToCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addCustomFilterToCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddCustomFilterToCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addCustomFilterToCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddFilterListInCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addFilterListInCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddFilterListInCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addFilterListInCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, MissingConfiguration) {
+  EXPECT_TRUE(RunTest("missingConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       MissingConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("missingConfigurationWithPromises")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, AllowedDomainsEvent) {
+  EXPECT_TRUE(RunTest("allowedDomainsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, EnabledStateEvent) {
+  EXPECT_TRUE(RunTest("enabledStateEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, FilterListsEvent) {
+  EXPECT_TRUE(RunTest("filterListsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, CustomFiltersEvent) {
+  EXPECT_TRUE(RunTest("customFiltersEvent")) << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(,
+                         EyeoFilteringPrivateApiTest,
+                         testing::Values(Mode::Normal, Mode::Incognito));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/extension_function_registration_test.cc b/chrome/browser/extensions/extension_function_registration_test.cc
index f384225e77c8b..dc4298f8048d5 100644
--- a/chrome/browser/extensions/extension_function_registration_test.cc
+++ b/chrome/browser/extensions/extension_function_registration_test.cc
@@ -1,6 +1,10 @@
 // Copyright 2018 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "base/containers/contains.h"
 #include "base/one_shot_event.h"
@@ -58,6 +62,13 @@ IN_PROC_BROWSER_TEST_F(ExtensionFunctionRegistrationTest,
                            base::CompareCase::SENSITIVE)) {
         continue;
       }
+      // Eyeo extension API uses UNKNOWN; it's not used in histograms.
+      if (base::StartsWith(entry.function_name_, "adblockPrivate.") ||
+          base::StartsWith(entry.function_name_, "eyeoDevToolsPrivate.") ||
+          base::StartsWith(entry.function_name_, "eyeoFilteringPrivate.")) {
+        continue;
+      }
+
       // Some undocumented, unlaunched APIs may also use UNKNOWN if it's unclear
       // (or unlikely) if they will ever launch.
       if (base::Contains(kAllowedUnknownHistogramEntries,
diff --git a/chrome/browser/net/errorpage_browsertest.cc b/chrome/browser/net/errorpage_browsertest.cc
index 0e01ba33df3fd..3e30bbbc59cd1 100644
--- a/chrome/browser/net/errorpage_browsertest.cc
+++ b/chrome/browser/net/errorpage_browsertest.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
+
 #include <algorithm>
 #include <memory>
 #include <utility>
@@ -38,6 +42,7 @@
 #include "chrome/common/pref_names.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/common/adblock_switches.h"
 #include "components/browsing_data/content/browsing_data_helper.h"
 #include "components/embedder_support/switches.h"
 #include "components/error_page/content/browser/net_error_auto_reloader.h"
@@ -639,6 +644,9 @@ class ErrorPageAutoReloadTest : public InProcessBrowserTest {
  public:
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitch(embedder_support::kEnableAutoReload);
+    // The URLLoaderInterceptor is not resilient to the browser making
+    // adblock-related requests, they confuse this test.
+    command_line->AppendSwitch(adblock::switches::kDisableAdblock);
   }
 
   void TearDownOnMainThread() override { url_loader_interceptor_.reset(); }
diff --git a/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc b/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
index 9de5c66ca4cd4..0a6aa800da104 100644
--- a/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
+++ b/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "components/page_load_metrics/browser/observers/ad_metrics/ads_page_load_metrics_observer.h"
 
@@ -23,6 +27,7 @@
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/interactive_test_utils.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/heavy_ad_intervention/heavy_ad_features.h"
 #include "components/page_load_metrics/browser/ads_page_load_metrics_test_waiter.h"
 #include "components/page_load_metrics/browser/features.h"
@@ -1513,7 +1518,7 @@ class AdsPageLoadMetricsObserverResourceBrowserTest
          {heavy_ad_intervention::features::kHeavyAdIntervention, {}},
          {heavy_ad_intervention::features::kHeavyAdPrivacyMitigations,
           {{"host-threshold", "3"}}}},
-        {});
+         {adblock::kAdblockPlusFeature});
     if (IsReduceTransferSizeUpdatedIPCEnabled()) {
       reduce_ipc_feature_list_.InitAndEnableFeature(
           network::features::kReduceTransferSizeUpdatedIPC);
diff --git a/chrome/browser/preferences/BUILD.gn b/chrome/browser/preferences/BUILD.gn
index 895b8c5d91839..780869b673687 100644
--- a/chrome/browser/preferences/BUILD.gn
+++ b/chrome/browser/preferences/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2019 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/android/rules.gni")
 import("//third_party/jni_zero/jni_zero.gni")
@@ -54,6 +57,7 @@ java_cpp_strings("java_pref_names_srcjar") {
     "//chrome/browser/enterprise/reporting/prefs.cc",
     "//chrome/browser/ui/safety_hub/safety_hub_prefs.h",
     "//chrome/common/pref_names.h",
+    "//components/adblock/core/common/adblock_prefs.cc",
     "//components/autofill/core/common/autofill_prefs.h",
     "//components/bookmarks/common/bookmark_pref_names.h",
     "//components/commerce/core/pref_names.h",
diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
index 1ade93d9ea505..4c8ab4cd5a785 100644
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -98,6 +98,7 @@
 #include "chrome/common/buildflags.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/common/secure_origin_allowlist.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/autofill/core/common/autofill_prefs.h"
 #include "components/blocked_content/safe_browsing_triggered_popup_blocker.h"
 #include "components/breadcrumbs/core/breadcrumbs_status.h"
@@ -2869,6 +2870,7 @@ void MigrateObsoleteProfilePrefs(PrefService* profile_prefs,
   profile_prefs->ClearPref(kObsoleteLocalPasswordMigrationWarningPrefsVersion);
 #endif
 
+  adblock::common::prefs::MigrateDeprecatedAdblockPrefs(profile_prefs);
   // Added 04/2025.
   profile_prefs->ClearPref(kSuggestionGroupVisibility);
 
diff --git a/chrome/browser/prefs/chrome_pref_service_factory.cc b/chrome/browser/prefs/chrome_pref_service_factory.cc
index 3d946ce955030..3dee439ea294d 100644
--- a/chrome/browser/prefs/chrome_pref_service_factory.cc
+++ b/chrome/browser/prefs/chrome_pref_service_factory.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/prefs/chrome_pref_service_factory.h"
 
@@ -43,6 +47,7 @@
 #include "chrome/grit/branded_strings.h"
 #include "chrome/grit/browser_resources.h"
 #include "chrome/grit/generated_resources.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/component_updater/pref_names.h"
 #include "components/policy/core/browser/configuration_policy_pref_store.h"
 #include "components/pref_registry/pref_registry_syncable.h"
@@ -183,6 +188,12 @@ const auto kTrackedPrefs = std::to_array<prefs::TrackedPreferenceMetadata>({
     {35, prefs::kExtensionsUIDeveloperMode, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #endif
+    {100, adblock::common::prefs::kSubscriptionSignatures,
+     EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::SPLIT,
+     ValueType::IMPERSONAL},
+    {101, adblock::common::prefs::kLastUsedSchemaVersion,
+     EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::ATOMIC,
+     ValueType::IMPERSONAL}
 
     // See note at top, new items added here also need to be added to
     // histograms.xml's TrackedPreference enum.
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
index 85af5360465b8..4c44a98a142fb 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -1,6 +1,10 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h"
 
@@ -241,6 +245,15 @@
 #include "chrome/browser/webid/federated_identity_permission_context_factory.h"
 #include "chrome/common/buildflags.h"
 #include "chrome/common/chrome_features.h"
+#include "components/adblock/content/browser/factories/adblock_request_throttle_factory.h"
+#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
+#include "components/adblock/content/browser/factories/content_security_policy_injector_factory.h"
+#include "components/adblock/content/browser/factories/element_hider_factory.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/sitekey_storage_factory.h"
+#include "components/adblock/content/browser/factories/subscription_persistent_metadata_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
 #include "components/autofill/content/browser/autofill_log_router_factory.h"
 #include "components/breadcrumbs/core/breadcrumbs_status.h"
 #include "components/captive_portal/core/buildflags.h"
@@ -911,6 +924,15 @@ void ChromeBrowserMainExtraPartsProfiles::
   // Makes manual testing possible.
   FakeSmartCardDeviceServiceFactory::GetInstance();
 #endif
+  adblock::AdblockTelemetryServiceFactory::GetInstance();
+  adblock::AdblockRequestThrottleFactory::GetInstance();
+  adblock::ContentSecurityPolicyInjectorFactory::GetInstance();
+  adblock::ElementHiderFactory::GetInstance();
+  adblock::ResourceClassificationRunnerFactory::GetInstance();
+  adblock::SessionStatsFactory::GetInstance();
+  adblock::SitekeyStorageFactory::GetInstance();
+  adblock::SubscriptionPersistentMetadataFactory::GetInstance();
+  adblock::SubscriptionServiceFactory::GetInstance();
 #if BUILDFLAG(IS_ANDROID)
   FastCheckoutCapabilitiesFetcherFactory::GetInstance();
 #endif
diff --git a/chrome/browser/profiles/profile_keyed_service_browsertest.cc b/chrome/browser/profiles/profile_keyed_service_browsertest.cc
index 72ff470b46fe5..5ce4701f2433d 100644
--- a/chrome/browser/profiles/profile_keyed_service_browsertest.cc
+++ b/chrome/browser/profiles/profile_keyed_service_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2022 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include <algorithm>
 #include <sstream>
@@ -277,6 +281,17 @@ IN_PROC_BROWSER_TEST_F(ProfileKeyedServiceBrowserTest,
     "PermissionsUpdaterShutdownFactory",
     "PluginInfoHostImpl",
     "TurnSyncOnHelperShutdownNotifier",
+
+    // Eyeo services
+    "AdblockRequestThrottle",
+    "AdblockSubscriptionPersistentMetadata",
+    "AdblockSubscriptionService",
+    "AdblockTelemetryService",
+    "ContentSecurityPolicyInjector",
+    "ElementHider",
+    "ResourceClassificationRunner",
+    "SessionStats",
+    "SitekeyStorage",
   };
   // clang-format on
 
@@ -852,6 +867,20 @@ IN_PROC_BROWSER_TEST_F(ProfileKeyedServiceGuestBrowserTest,
     "ZeroSuggestCacheServiceFactory",
 #endif  // !BUILDFLAG(IS_CHROMEOS)
 
+    // eyeo Chromium SDK services:
+    "AdblockPrivateAPI",
+    "AdblockRequestThrottle",
+    "AdblockSubscriptionPersistentMetadata",
+    "AdblockSubscriptionService",
+    "AdblockTelemetryService",
+    "ContentSecurityPolicyInjector",
+    "ElementHider",
+    "EyeoDevToolsPrivateAPI",
+    "EyeoFilteringPrivateAPI",
+    "ResourceClassificationRunner",
+    "SessionStats",
+    "SitekeyStorage",
+
 #if BUILDFLAG(IS_CHROMEOS)
     // TODO(crbug.com/374351946):
     // Verify these are necessary: then reorder or remove.
diff --git a/chrome/browser/resources/BUILD.gn b/chrome/browser/resources/BUILD.gn
index 5e51b87522cbb..b6017fbb155ce 100644
--- a/chrome/browser/resources/BUILD.gn
+++ b/chrome/browser/resources/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//chrome/browser/buildflags.gni")
 import("//chrome/common/features.gni")
@@ -284,6 +287,7 @@ group("dev_ui_resources") {
     "predictors:resources",
     "privacy_sandbox/internals:resources",
     "usb_internals:resources",
+    "//components/adblock/content/resources/adblock_internals:resources",
     "//components/commerce/core/internals/resources",
     "//components/data_sharing/data_sharing_internals/resources",
     "//components/download/resources/download_internals:resources",
@@ -351,6 +355,7 @@ repack("dev_ui_paks") {
     "$root_gen_dir/chrome/predictors_resources.pak",
     "$root_gen_dir/chrome/privacy_sandbox_internals_resources.pak",
     "$root_gen_dir/chrome/usb_internals_resources.pak",
+    "$root_gen_dir/components/adblock_internals_resources.pak",
     "$root_gen_dir/components/commerce_internals_resources.pak",
     "$root_gen_dir/components/data_sharing_internals_resources.pak",
     "$root_gen_dir/components/dev_ui_components_resources.pak",
diff --git a/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc b/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
index d522ad0e85f64..04506020dab0d 100644
--- a/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
+++ b/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
@@ -5,6 +5,10 @@
 // This test creates a fake safebrowsing service, where we can inject known-
 // threat urls.  It then uses a real browser to go to these urls, and sends
 // "goback" or "proceed" commands and verifies they work.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "components/safe_browsing/content/browser/safe_browsing_blocking_page.h"
 
@@ -68,6 +72,7 @@
 #include "chrome/common/url_constants.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/enterprise/connectors/core/common.h"
 #include "components/enterprise/connectors/core/connectors_prefs.h"
 #include "components/google/core/common/google_util.h"
@@ -358,7 +363,7 @@ class SafeBrowsingBlockingPageBrowserTest
     scoped_feature_list_.InitWithFeaturesAndParameters(
         {tag_and_attribute, add_warning_shown_timestamp_csbrrs,
          create_warning_shown_csbrrs, abusive_notification_revocation},
-        {});
+        {adblock::kAdblockPlusFeature});
   }
 
   SafeBrowsingBlockingPageBrowserTest(
diff --git a/chrome/browser/sessions/session_restore_browsertest.cc b/chrome/browser/sessions/session_restore_browsertest.cc
index 315a9cd3abf1a..4aa03a3c399b8 100644
--- a/chrome/browser/sessions/session_restore_browsertest.cc
+++ b/chrome/browser/sessions/session_restore_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
@@ -4404,8 +4408,10 @@ class SessionRestoreStaleSessionCookieDeletionTest : public SessionRestoreTest {
   net::EmbeddedTestServer https_server_;
 };
 
-IN_PROC_BROWSER_TEST_F(SessionRestoreStaleSessionCookieDeletionTest,
-                       CookieStorage) {
+// Disabled as it's flaky, see: https://issues.chromium.org/issues/348923077
+// See also: https://eyeo.atlassian.net/browse/DPD-2773
+IN_PROC_BROWSER_TEST_P(SessionRestoreStaleSessionCookieDeletionTest,
+                       DISABLED_CookieStorage) {
   GURL open_page = https_server()->GetURL("a.test", "/empty.html");
   GURL other_page = https_server()->GetURL("b.test", "/empty.html");
   ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), open_page));
diff --git a/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc b/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
index afa46eb6e6982..d931be54dd7a6 100644
--- a/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
+++ b/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/subresource_filter/subresource_filter_browser_test_harness.h"
 
@@ -22,6 +26,7 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
 #include "chrome/test/base/chrome_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/blocked_content/safe_browsing_triggered_popup_blocker.h"
 #include "components/content_settings/browser/page_specific_content_settings.h"
 #include "components/safe_browsing/core/browser/db/v4_protocol_manager_util.h"
@@ -152,7 +157,8 @@ void SubresourceFilterSharedBrowserTest::NavigateFrame(const char* frame_name,
 SubresourceFilterBrowserTest::SubresourceFilterBrowserTest() {
   scoped_feature_list_.InitWithFeatures(
       /*enabled_features=*/{kAdTagging},
-      /*disabled_features=*/{features::kHttpsUpgrades});
+      /*disabled_features=*/{features::kHttpsUpgrades,
+                             adblock::kAdblockPlusFeature});
 }
 
 SubresourceFilterBrowserTest::~SubresourceFilterBrowserTest() = default;
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 8392975cdde4e..c00d4131ea0a3 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/buildflags_paint_preview.gni")
 import("//build/config/compiler/compiler.gni")
@@ -424,6 +427,7 @@ static_library("ui") {
     "//chrome/services/media_gallery_util/public/mojom",
     "//components/access_code_cast/common:metrics",
     "//components/account_id",
+    "//components/adblock/content:browser",
     "//components/affiliations/core/browser:affiliations",
     "//components/autofill/content/browser",
     "//components/autofill/content/browser:risk_proto",
@@ -948,6 +952,14 @@ static_library("ui") {
     # Any circular includes must depend on the target "//chrome/browser:browser_public_dependencies".
     allow_circular_includes_from += [ "//chrome/browser/facilitated_payments" ]
 
+    ### Android API module start
+    deps += [
+      "//components/adblock/android:java_bindings",
+      "//components/adblock/android:jni_headers",
+    ]
+
+    ### Android API module end
+
     if (enable_extensions_core) {
       sources += [
         "android/extensions/extension_keybinding_registry_android.cc",
diff --git a/chrome/browser/ui/prefs/pref_watcher.cc b/chrome/browser/ui/prefs/pref_watcher.cc
index 1c7d3b2ddd3f0..774f5026f0740 100644
--- a/chrome/browser/ui/prefs/pref_watcher.cc
+++ b/chrome/browser/ui/prefs/pref_watcher.cc
@@ -1,6 +1,10 @@
 // Copyright 2018 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/ui/prefs/pref_watcher.h"
 
@@ -21,6 +25,7 @@
 #include "chrome/browser/renderer_preferences_util.h"
 #include "chrome/browser/ui/prefs/prefs_tab_helper.h"
 #include "chrome/common/pref_names.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/language/core/browser/pref_names.h"
 #include "components/live_caption/pref_names.h"
@@ -82,6 +87,14 @@ const char* const kWebPrefsToObserve[] = {
     prefs::kAccessibilityFocusHighlightEnabled,
 #endif
     prefs::kPageColorsBlockList,
+
+    adblock::common::prefs::kAdblockAllowedDomainsLegacy,
+    adblock::common::prefs::kAdblockCustomFiltersLegacy,
+    adblock::common::prefs::kAdblockCustomSubscriptionsLegacy,
+    adblock::common::prefs::kAdblockSubscriptionsLegacy,
+    adblock::common::prefs::kEnableAcceptableAdsLegacy,
+    adblock::common::prefs::kEnableAdblockLegacy,
+
 };
 
 }  // namespace
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
index 8b3b888ead6d9..8df1fc2088aab 100644
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -1,6 +1,10 @@
 // Copyright 2014 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/ui/tab_helpers.h"
 
@@ -101,6 +105,8 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_isolated_world_ids.h"
 #include "chrome/common/chrome_switches.h"
+#include "components/adblock/content/browser/adblock_webcontents_observer.h"
+#include "components/adblock/content/browser/factories/embedding_utils.h"
 #include "components/autofill/content/browser/content_autofill_client.h"
 #include "components/autofill/content/browser/content_autofill_driver_factory.h"
 #include "components/autofill/core/browser/foundations/browser_autofill_manager.h"
@@ -342,6 +348,12 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
                                                    optimization_guide_decider);
     }
   }
+
+  auto* original_profile = profile->GetOriginalProfile();
+  adblock::EnsureBackgroundServicesStarted(original_profile);
+  adblock::RegisterAdblockWebContentObserver<
+      adblock::AdblockWebContentObserver>(web_contents, original_profile);
+
   autofill::AutofillClientProvider& autofill_client_provider =
       autofill::AutofillClientProviderFactory::GetForProfile(profile);
   autofill_client_provider.CreateClientForWebContents(web_contents);
@@ -379,6 +391,7 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
     ip_protection::IpProtectionStatus::CreateForWebContents(web_contents);
   }
 #endif  // BUILDFLAG(IS_ANDROID)
+
   if (breadcrumbs::IsEnabled(g_browser_process->local_state())) {
     BreadcrumbManagerTabHelper::CreateForWebContents(web_contents);
   }
-- 
2.43.0

